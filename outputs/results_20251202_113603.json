[
  {
    "problem_id": "fizzbuzz",
    "problem_name": "FizzBuzz",
    "prompt": "Write a function that prints numbers from 1 to 100. For multiples of 3, print 'Fizz'. For multiples of 5, print 'Buzz'. For multiples of both, print 'FizzBuzz'.",
    "style": "pattern_brained",
    "response": "I'll implement the FizzBuzz problem using proper software architecture principles with design patterns and SOLID principles.\n\n```python\nfrom abc import ABC, abstractmethod\nfrom typing import List, Dict\nfrom dataclasses import dataclass\n\n\nclass Rule(ABC):\n    \"\"\"Abstract base class for FizzBuzz rules following Strategy pattern.\"\"\"\n    \n    @abstractmethod\n    def applies(self, number: int) -> bool:\n        \"\"\"Check if this rule applies to the given number.\"\"\"\n        pass\n    \n    @abstractmethod\n    def get_output(self) -> str:\n        \"\"\"Get the output string for this rule.\"\"\"\n        pass\n\n\nclass DivisibilityRule(Rule):\n    \"\"\"Concrete rule for divisibility-based conditions.\"\"\"\n    \n    def __init__(self, divisor: int, output: str):\n        self._divisor = divisor\n        self._output = output\n    \n    def applies(self, number: int) -> bool:\n        return number % self._divisor == 0\n    \n    def get_output(self) -> str:\n        return self._output\n\n\nclass CompositeRule(Rule):\n    \"\"\"Composite rule that combines multiple rules using AND logic.\"\"\"\n    \n    def __init__(self, rules: List[Rule], output: str):\n        self._rules = rules\n        self._output = output\n    \n    def applies(self, number: int) -> bool:\n        return all(rule.applies(number) for rule in self._rules)\n    \n    def get_output(self) -> str:\n        return self._output\n\n\n@dataclass\nclass NumberRange:\n    \"\"\"Value object representing a range of numbers.\"\"\"\n    start: int\n    end: int\n    \n    def __post_init__(self):\n        if self.start > self.end:\n            raise ValueError(\"Start must be less than or equal to end\")\n\n\nclass RuleEngine:\n    \"\"\"Engine that processes numbers against a set of rules.\"\"\"\n    \n    def __init__(self):\n        self._rules: List[Rule] = []\n    \n    def add_rule(self, rule: Rule) -> None:\n        \"\"\"Add a rule to the engine. Rules are evaluated in order of addition.\"\"\"\n        self._rules.append(rule)\n    \n    def process_number(self, number: int) -> str:\n        \"\"\"Process a number against all rules, returning the first match or the number itself.\"\"\"\n        for rule in self._rules:\n            if rule.applies(number):\n                return rule.get_output()\n        return str(number)\n\n\nclass OutputWriter(ABC):\n    \"\"\"Abstract base class for output writers following Strategy pattern.\"\"\"\n    \n    @abstractmethod\n    def write(self, content: str) -> None:\n        pass\n\n\nclass ConsoleWriter(OutputWriter):\n    \"\"\"Concrete writer that outputs to console.\"\"\"\n    \n    def write(self, content: str) -> None:\n        print(content)\n\n\nclass FizzBuzzRuleFactory:\n    \"\"\"Factory for creating standard FizzBuzz rules.\"\"\"\n    \n    @staticmethod\n    def create_standard_rules() -> List[Rule]:\n        \"\"\"Create the standard FizzBuzz rules.\"\"\"\n        fizz_rule = DivisibilityRule(3, \"Fizz\")\n        buzz_rule = DivisibilityRule(5, \"Buzz\")\n        fizzbuzz_rule = CompositeRule([fizz_rule, buzz_rule], \"FizzBuzz\")\n        \n        # Order matters: more specific rules first\n        return [fizzbuzz_rule, fizz_rule, buzz_rule]\n\n\nclass FizzBuzzGame:\n    \"\"\"Main game class that orchestrates the FizzBuzz logic.\"\"\"\n    \n    def __init__(self, rule_engine: RuleEngine, output_writer: OutputWriter):\n        self._rule_engine = rule_engine\n        self._output_writer = output_writer\n    \n    def play(self, number_range: NumberRange) -> None:\n        \"\"\"Play the FizzBuzz game for the given range.\"\"\"\n        for number in range(number_range.start, number_range.end + 1):\n            result = self._rule_engine.process_number(number)\n            self._output_writer.write(result)\n\n\nclass FizzBuzzGameBuilder:\n    \"\"\"Builder pattern for constructing FizzBuzz game instances.\"\"\"\n    \n    def __init__(self):\n        self._rule_engine = RuleEngine()\n        self._output_writer: OutputWriter = ConsoleWriter()\n    \n    def with_standard_rules(self) -> 'FizzBuzzGameBuilder':\n        \"\"\"Add standard FizzBuzz rules.\"\"\"\n        rules = FizzBuzzRuleFactory.create_standard_rules()\n        for rule in rules:\n            self._rule_engine.add_rule(rule)\n        return self\n    \n    def with_custom_rule(self, rule: Rule) -> 'FizzBuzzGameBuilder':\n        \"\"\"Add a custom rule.\"\"\"\n        self._rule_engine.add_rule(rule)\n        return self\n    \n    def with_output_writer(self, writer: OutputWriter) -> 'FizzBuzzGameBuilder':\n        \"\"\"Set custom output writer.\"\"\"\n        self._output_writer = writer\n        return self\n    \n    def build(self) -> FizzBuzzGame:\n        \"\"\"Build the FizzBuzz game instance.\"\"\"\n        return FizzBuzzGame(self._rule_engine, self._output_writer)\n\n\ndef main():\n    \"\"\"Main function demonstrating the FizzBuzz implementation.\"\"\"\n    # Build and configure the game\n    game = (FizzBuzzGameBuilder()\n            .with_standard_rules()\n            .build())\n    \n    # Define the range\n    number_range = NumberRange(1, 100)\n    \n    # Play the game\n    game.play(number_range)\n\n\n# Example of extending the system with custom rules\ndef example_with_custom_rules():\n    \"\"\"Example showing how to extend the system with custom rules.\"\"\"\n    \n    # Create custom rules\n    seven_rule = DivisibilityRule(7, \"Lucky\")\n    eleven_rule = DivisibilityRule(11, \"Boom\")\n    \n    # Build game with custom rules\n    game = (FizzBuzzGameBuilder()\n            .with_standard_rules()\n            .with_custom_rule(seven_rule)\n            .with_custom_rule(eleven_rule)\n            .build())\n    \n    # Play with custom range\n    game.play(NumberRange(1, 30))\n\n\nif __name__ == \"__main__\":\n    main()\n```\n\nThis implementation demonstrates several key design patterns and architectural principles:\n\n## Design Patterns Used:\n\n1. **Strategy Pattern**: `Rule` hierarchy allows different rule implementations\n2. **Composite Pattern**: `CompositeRule` combines multiple rules\n3. **Factory Pattern**: `FizzBuzzRuleFactory` creates standard rule sets\n4. **Builder Pattern**: `FizzBuzzGameBuilder` constructs game instances\n5. **Template Method**: Abstract base classes define structure\n\n## SOLID Principles:\n\n1. **Single Responsibility**: Each class has one clear purpose\n2. **Open/Closed**: Easy to add new rules without modifying existing code\n3. **Liskov Substitution**: All rule implementations are interchangeable\n4. **Interface Segregation**: Clean, focused interfaces\n5. **Dependency Inversion**: Depends on abstractions, not concretions\n\n## Key Features:\n\n- **Extensible**: Easy to add new rules or output formats\n- **Testable**: Each component can be unit tested independently  \n- **Maintainable**: Clear separation of concerns\n- **Configurable**: Rules and output can be customized\n- **Type Safe**: Proper type hints throughout\n- **Error Handling**: Input validation where appropriate\n\nThe architecture makes it trivial to extend (add new rules, output formats) while maintaining the existing functionality intact.",
    "output_tokens": 1839
  },
  {
    "problem_id": "fizzbuzz",
    "problem_name": "FizzBuzz",
    "prompt": "Write a function that prints numbers from 1 to 100. For multiples of 3, print 'Fizz'. For multiples of 5, print 'Buzz'. For multiples of both, print 'FizzBuzz'.",
    "style": "simple",
    "response": "```python\ndef fizzbuzz():\n    for i in range(1, 101):\n        if i % 15 == 0:\n            print(\"FizzBuzz\")\n        elif i % 3 == 0:\n            print(\"Fizz\")\n        elif i % 5 == 0:\n            print(\"Buzz\")\n        else:\n            print(i)\n\nfizzbuzz()\n```\n\nThat's it. Simple, direct, and does exactly what's needed.",
    "output_tokens": 116
  },
  {
    "problem_id": "reverse_string",
    "problem_name": "Reverse String",
    "prompt": "Write a function that reverses a string.",
    "style": "pattern_brained",
    "response": "I'll create a well-architected string reversal solution using proper design patterns and SOLID principles.\n\n```python\nfrom abc import ABC, abstractmethod\nfrom typing import Optional, Protocol\nfrom enum import Enum\n\n\nclass ReversalStrategy(Protocol):\n    \"\"\"Protocol defining the interface for string reversal strategies.\"\"\"\n    \n    def reverse(self, text: str) -> str:\n        \"\"\"Reverse the given text string.\"\"\"\n        ...\n\n\nclass ReversalMethod(Enum):\n    \"\"\"Enumeration of available reversal methods.\"\"\"\n    SLICE = \"slice\"\n    ITERATIVE = \"iterative\" \n    RECURSIVE = \"recursive\"\n\n\nclass SliceReversalStrategy:\n    \"\"\"Strategy implementing string reversal using Python slicing.\"\"\"\n    \n    def reverse(self, text: str) -> str:\n        \"\"\"Reverse string using slice notation [::-1].\"\"\"\n        return text[::-1]\n\n\nclass IterativeReversalStrategy:\n    \"\"\"Strategy implementing string reversal using iterative approach.\"\"\"\n    \n    def reverse(self, text: str) -> str:\n        \"\"\"Reverse string by iterating through characters.\"\"\"\n        return ''.join(reversed(text))\n\n\nclass RecursiveReversalStrategy:\n    \"\"\"Strategy implementing string reversal using recursion.\"\"\"\n    \n    def reverse(self, text: str) -> str:\n        \"\"\"Reverse string using recursive divide-and-conquer.\"\"\"\n        if len(text) <= 1:\n            return text\n        return text[-1] + self.reverse(text[:-1])\n\n\nclass ReversalStrategyFactory:\n    \"\"\"Factory for creating reversal strategy instances.\"\"\"\n    \n    _strategies = {\n        ReversalMethod.SLICE: SliceReversalStrategy,\n        ReversalMethod.ITERATIVE: IterativeReversalStrategy,\n        ReversalMethod.RECURSIVE: RecursiveReversalStrategy,\n    }\n    \n    @classmethod\n    def create_strategy(self, method: ReversalMethod) -> ReversalStrategy:\n        \"\"\"Create and return a reversal strategy instance.\"\"\"\n        if method not in self._strategies:\n            raise ValueError(f\"Unsupported reversal method: {method}\")\n        \n        return self._strategies[method]()\n    \n    @classmethod\n    def get_available_methods(self) -> list[ReversalMethod]:\n        \"\"\"Return list of available reversal methods.\"\"\"\n        return list(self._strategies.keys())\n\n\nclass StringValidator:\n    \"\"\"Utility class for validating string inputs.\"\"\"\n    \n    @staticmethod\n    def validate_input(text: Optional[str]) -> str:\n        \"\"\"Validate and normalize input string.\"\"\"\n        if text is None:\n            raise ValueError(\"Input text cannot be None\")\n        \n        if not isinstance(text, str):\n            raise TypeError(f\"Expected str, got {type(text).__name__}\")\n        \n        return text\n\n\nclass StringReverser:\n    \"\"\"Main service class for string reversal operations.\"\"\"\n    \n    def __init__(self, strategy: Optional[ReversalStrategy] = None):\n        \"\"\"Initialize with optional custom strategy.\"\"\"\n        self._strategy = strategy or SliceReversalStrategy()\n        self._validator = StringValidator()\n    \n    def set_strategy(self, strategy: ReversalStrategy) -> None:\n        \"\"\"Change the reversal strategy at runtime.\"\"\"\n        self._strategy = strategy\n    \n    def reverse(self, text: str) -> str:\n        \"\"\"\n        Reverse the given string using the current strategy.\n        \n        Args:\n            text: The string to reverse\n            \n        Returns:\n            The reversed string\n            \n        Raises:\n            ValueError: If text is None\n            TypeError: If text is not a string\n        \"\"\"\n        validated_text = self._validator.validate_input(text)\n        return self._strategy.reverse(validated_text)\n\n\nclass StringReversalService:\n    \"\"\"\n    High-level service providing string reversal functionality.\n    \n    This class serves as a facade, simplifying the interface for clients\n    while encapsulating the complexity of strategy selection and validation.\n    \"\"\"\n    \n    def __init__(self):\n        \"\"\"Initialize the service with default strategy.\"\"\"\n        self._reverser = StringReverser()\n        self._factory = ReversalStrategyFactory()\n    \n    def reverse_string(\n        self, \n        text: str, \n        method: ReversalMethod = ReversalMethod.SLICE\n    ) -> str:\n        \"\"\"\n        Reverse a string using the specified method.\n        \n        Args:\n            text: The string to reverse\n            method: The reversal method to use\n            \n        Returns:\n            The reversed string\n        \"\"\"\n        strategy = self._factory.create_strategy(method)\n        self._reverser.set_strategy(strategy)\n        return self._reverser.reverse(text)\n    \n    def get_available_methods(self) -> list[ReversalMethod]:\n        \"\"\"Get list of available reversal methods.\"\"\"\n        return self._factory.get_available_methods()\n\n\n# Convenience function for simple usage\ndef reverse_string(text: str, method: ReversalMethod = ReversalMethod.SLICE) -> str:\n    \"\"\"\n    Convenience function to reverse a string.\n    \n    Args:\n        text: The string to reverse\n        method: The reversal method to use (default: slice)\n        \n    Returns:\n        The reversed string\n        \n    Example:\n        >>> reverse_string(\"hello\")\n        'olleh'\n        >>> reverse_string(\"world\", ReversalMethod.RECURSIVE)\n        'dlrow'\n    \"\"\"\n    service = StringReversalService()\n    return service.reverse_string(text, method)\n\n\n# Example usage and testing\nif __name__ == \"__main__\":\n    # Demonstrate different usage patterns\n    \n    # Simple function usage\n    print(\"Simple function usage:\")\n    print(f\"reverse_string('Hello World'): {reverse_string('Hello World')}\")\n    \n    # Service usage with different strategies\n    print(\"\\nService usage with different strategies:\")\n    service = StringReversalService()\n    \n    text = \"Design Patterns\"\n    for method in service.get_available_methods():\n        result = service.reverse_string(text, method)\n        print(f\"{method.value}: '{text}' -> '{result}'\")\n    \n    # Direct class usage for more control\n    print(\"\\nDirect class usage:\")\n    reverser = StringReverser()\n    \n    # Change strategies at runtime\n    strategies = [\n        (\"Slice\", SliceReversalStrategy()),\n        (\"Iterative\", IterativeReversalStrategy()),\n        (\"Recursive\", RecursiveReversalStrategy()),\n    ]\n    \n    test_text = \"Architecture\"\n    for name, strategy in strategies:\n        reverser.set_strategy(strategy)\n        result = reverser.reverse(test_text)\n        print(f\"{name} strategy: '{test_text}' -> '{result}'\")\n    \n    # Error handling demonstration\n    print(\"\\nError handling:\")\n    try:\n        reverse_string(None)\n    except ValueError as e:\n        print(f\"Caught expected error: {e}\")\n    \n    try:\n        reverse_string(123)\n    except TypeError as e:\n        print(f\"Caught expected error: {e}\")\n```\n\nThis implementation demonstrates several key design patterns and architectural principles:\n\n## Design Patterns Used:\n\n1. **Strategy Pattern**: Multiple algorithms for string reversal that can be switched at runtime\n2. **Factory Pattern**: `ReversalStrategyFactory` creates strategy instances\n3. **Facade Pattern**: `StringReversalService` provides a simplified interface\n4. **Protocol/Interface Segregation**: `ReversalStrategy` protocol defines the contract\n\n## SOLID Principles:\n\n1. **Single Responsibility**: Each class has one clear purpose\n2. **Open/Closed**: Easy to add new reversal strategies without modifying existing code\n3. **Liskov Substitution**: All strategies are interchangeable\n4. **Interface Segregation**: Clean, focused protocols\n5. **Dependency Inversion**: High-level modules depend on abstractions\n\n## Key Features:\n\n- **Extensible**: Easy to add new reversal algorithms\n- **Configurable**: Multiple ways to use the functionality\n- **Robust**: Comprehensive input validation and error handling\n- **Testable**: Clear separation of concerns makes unit testing straightforward\n- **Production-ready**: Proper typing, documentation, and error handling\n\nThe solution provides both simple function usage and full object-oriented architecture, allowing clients to choose the appropriate level of complexity for their needs.",
    "output_tokens": 2023
  },
  {
    "problem_id": "reverse_string",
    "problem_name": "Reverse String",
    "prompt": "Write a function that reverses a string.",
    "style": "simple",
    "response": "```python\ndef reverse_string(s):\n    return s[::-1]\n```\n\nThat's it. Python's slice notation `[::-1]` is the most direct way to reverse a string - no loops, no extra variables, no complexity.",
    "output_tokens": 58
  },
  {
    "problem_id": "fibonacci",
    "problem_name": "Fibonacci",
    "prompt": "Write a function that returns the nth Fibonacci number.",
    "style": "pattern_brained",
    "response": "I'll create a well-architected Fibonacci calculator using proper design patterns and SOLID principles.\n\n```python\nfrom abc import ABC, abstractmethod\nfrom typing import Dict, Optional\nfrom functools import wraps\nimport threading\n\n\nclass FibonacciStrategy(ABC):\n    \"\"\"Strategy interface for different Fibonacci calculation algorithms.\"\"\"\n    \n    @abstractmethod\n    def calculate(self, n: int) -> int:\n        \"\"\"Calculate the nth Fibonacci number.\"\"\"\n        pass\n    \n    @property\n    @abstractmethod\n    def name(self) -> str:\n        \"\"\"Return the strategy name.\"\"\"\n        pass\n\n\nclass MemoizedFibonacciStrategy(FibonacciStrategy):\n    \"\"\"Memoized recursive strategy for Fibonacci calculation.\"\"\"\n    \n    def __init__(self):\n        self._cache: Dict[int, int] = {0: 0, 1: 1}\n        self._lock = threading.RLock()\n    \n    def calculate(self, n: int) -> int:\n        \"\"\"Calculate using memoized recursion.\"\"\"\n        if n < 0:\n            raise ValueError(\"Fibonacci number is not defined for negative integers\")\n        \n        with self._lock:\n            if n in self._cache:\n                return self._cache[n]\n            \n            result = self.calculate(n - 1) + self.calculate(n - 2)\n            self._cache[n] = result\n            return result\n    \n    @property\n    def name(self) -> str:\n        return \"Memoized Recursive\"\n\n\nclass IterativeFibonacciStrategy(FibonacciStrategy):\n    \"\"\"Iterative strategy for Fibonacci calculation.\"\"\"\n    \n    def calculate(self, n: int) -> int:\n        \"\"\"Calculate using iterative approach.\"\"\"\n        if n < 0:\n            raise ValueError(\"Fibonacci number is not defined for negative integers\")\n        \n        if n <= 1:\n            return n\n        \n        prev, curr = 0, 1\n        for _ in range(2, n + 1):\n            prev, curr = curr, prev + curr\n        \n        return curr\n    \n    @property\n    def name(self) -> str:\n        return \"Iterative\"\n\n\nclass MatrixFibonacciStrategy(FibonacciStrategy):\n    \"\"\"Matrix exponentiation strategy for Fibonacci calculation.\"\"\"\n    \n    def calculate(self, n: int) -> int:\n        \"\"\"Calculate using matrix exponentiation.\"\"\"\n        if n < 0:\n            raise ValueError(\"Fibonacci number is not defined for negative integers\")\n        \n        if n <= 1:\n            return n\n        \n        def matrix_multiply(a: list, b: list) -> list:\n            \"\"\"Multiply two 2x2 matrices.\"\"\"\n            return [\n                [a[0][0] * b[0][0] + a[0][1] * b[1][0], a[0][0] * b[0][1] + a[0][1] * b[1][1]],\n                [a[1][0] * b[0][0] + a[1][1] * b[1][0], a[1][0] * b[0][1] + a[1][1] * b[1][1]]\n            ]\n        \n        def matrix_power(matrix: list, power: int) -> list:\n            \"\"\"Calculate matrix to the power using binary exponentiation.\"\"\"\n            if power == 1:\n                return matrix\n            \n            result = [[1, 0], [0, 1]]  # Identity matrix\n            base = matrix\n            \n            while power > 0:\n                if power % 2 == 1:\n                    result = matrix_multiply(result, base)\n                base = matrix_multiply(base, base)\n                power //= 2\n            \n            return result\n        \n        base_matrix = [[1, 1], [1, 0]]\n        result_matrix = matrix_power(base_matrix, n)\n        return result_matrix[0][1]\n    \n    @property\n    def name(self) -> str:\n        return \"Matrix Exponentiation\"\n\n\nclass FibonacciStrategyFactory:\n    \"\"\"Factory for creating Fibonacci calculation strategies.\"\"\"\n    \n    _strategies = {\n        'memoized': MemoizedFibonacciStrategy,\n        'iterative': IterativeFibonacciStrategy,\n        'matrix': MatrixFibonacciStrategy\n    }\n    \n    @classmethod\n    def create_strategy(cls, strategy_type: str) -> FibonacciStrategy:\n        \"\"\"Create a strategy instance.\"\"\"\n        if strategy_type not in cls._strategies:\n            raise ValueError(f\"Unknown strategy: {strategy_type}. \"\n                           f\"Available strategies: {list(cls._strategies.keys())}\")\n        \n        return cls._strategies[strategy_type]()\n    \n    @classmethod\n    def get_available_strategies(cls) -> list:\n        \"\"\"Get list of available strategy names.\"\"\"\n        return list(cls._strategies.keys())\n\n\nclass FibonacciCalculator:\n    \"\"\"Main calculator class that uses the Strategy pattern.\"\"\"\n    \n    def __init__(self, strategy: Optional[FibonacciStrategy] = None):\n        self._strategy = strategy or IterativeFibonacciStrategy()\n    \n    def set_strategy(self, strategy: FibonacciStrategy) -> None:\n        \"\"\"Set the calculation strategy.\"\"\"\n        self._strategy = strategy\n    \n    def calculate(self, n: int) -> int:\n        \"\"\"Calculate the nth Fibonacci number using the current strategy.\"\"\"\n        return self._strategy.calculate(n)\n    \n    @property\n    def current_strategy(self) -> str:\n        \"\"\"Get the name of the current strategy.\"\"\"\n        return self._strategy.name\n\n\nclass FibonacciService:\n    \"\"\"Service class that provides a high-level interface.\"\"\"\n    \n    def __init__(self):\n        self._calculator = FibonacciCalculator()\n        self._factory = FibonacciStrategyFactory()\n    \n    def get_fibonacci(self, n: int, strategy: str = 'iterative') -> int:\n        \"\"\"\n        Get the nth Fibonacci number using the specified strategy.\n        \n        Args:\n            n: The position in the Fibonacci sequence\n            strategy: The calculation strategy ('memoized', 'iterative', 'matrix')\n            \n        Returns:\n            The nth Fibonacci number\n            \n        Raises:\n            ValueError: If n is negative or strategy is unknown\n        \"\"\"\n        fibonacci_strategy = self._factory.create_strategy(strategy)\n        self._calculator.set_strategy(fibonacci_strategy)\n        return self._calculator.calculate(n)\n    \n    def get_available_strategies(self) -> list:\n        \"\"\"Get list of available calculation strategies.\"\"\"\n        return self._factory.get_available_strategies()\n\n\n# Singleton pattern for global access (if needed)\nclass FibonacciServiceSingleton:\n    \"\"\"Singleton wrapper for FibonacciService.\"\"\"\n    \n    _instance = None\n    _lock = threading.Lock()\n    \n    def __new__(cls):\n        if cls._instance is None:\n            with cls._lock:\n                if cls._instance is None:\n                    cls._instance = super().__new__(cls)\n                    cls._instance._service = FibonacciService()\n        return cls._instance\n    \n    def get_fibonacci(self, n: int, strategy: str = 'iterative') -> int:\n        \"\"\"Get the nth Fibonacci number.\"\"\"\n        return self._service.get_fibonacci(n, strategy)\n    \n    def get_available_strategies(self) -> list:\n        \"\"\"Get available strategies.\"\"\"\n        return self._service.get_available_strategies()\n\n\n# Convenient function interface\ndef fibonacci(n: int, strategy: str = 'iterative') -> int:\n    \"\"\"\n    Calculate the nth Fibonacci number.\n    \n    This is a convenient function interface that uses the well-architected\n    classes behind the scenes.\n    \n    Args:\n        n: The position in the Fibonacci sequence (0-indexed)\n        strategy: Calculation strategy ('iterative', 'memoized', 'matrix')\n        \n    Returns:\n        The nth Fibonacci number\n        \n    Raises:\n        ValueError: If n is negative or strategy is unknown\n        \n    Examples:\n        >>> fibonacci(0)\n        0\n        >>> fibonacci(1)\n        1\n        >>> fibonacci(10)\n        55\n        >>> fibonacci(10, strategy='matrix')\n        55\n    \"\"\"\n    service = FibonacciService()\n    return service.get_fibonacci(n, strategy)\n\n\n# Example usage and testing\nif __name__ == \"__main__\":\n    # Test the function interface\n    print(\"Testing function interface:\")\n    for i in range(10):\n        print(f\"F({i}) = {fibonacci(i)}\")\n    \n    # Test different strategies\n    print(f\"\\nF(20) with different strategies:\")\n    service = FibonacciService()\n    n = 20\n    \n    for strategy in service.get_available_strategies():\n        result = service.get_fibonacci(n, strategy)\n        print(f\"Strategy '{strategy}': F({n}) = {result}\")\n    \n    # Test error handling\n    try:\n        fibonacci(-1)\n    except ValueError as e:\n        print(f\"\\nError handling test: {e}\")\n    \n    # Performance test for large numbers\n    print(f\"\\nPerformance test F(1000):\")\n    import time\n    \n    for strategy in ['iterative', 'matrix']:\n        start_time = time.time()\n        result = fibonacci(1000, strategy)\n        end_time = time.time()\n        print(f\"{strategy}: {end_time - start_time:.6f} seconds\")\n```\n\nThis implementation demonstrates several key design patterns and architectural principles:\n\n## Design Patterns Used:\n\n1. **Strategy Pattern**: Different algorithms (iterative, memoized, matrix) implement the same interface\n2. **Factory Pattern**: `FibonacciStrategyFactory` creates strategy instances\n3. **Singleton Pattern**: `FibonacciServiceSingleton` for global access if needed\n\n## SOLID Principles:\n\n1. **Single Responsibility**: Each class has one clear purpose\n2. **Open/Closed**: Easy to add new strategies without modifying existing code\n3. **Liskov Substitution**: All strategies can be used interchangeably\n4. **Interface Segregation**: Clean, focused interfaces\n5. **Dependency Inversion**: High-level modules depend on abstractions\n\n## Key Features:\n\n- **Multiple Algorithms**: Iterative (O(n)), memoized recursive (O(n)), and matrix exponentiation (O(log n))\n- **Thread Safety**: Proper locking for concurrent access\n- **Error Handling**: Validates input and provides meaningful error messages\n- **Extensibility**: Easy to add new calculation strategies\n- **Performance**: Optimized algorithms for different use cases\n- **Clean Interface**: Simple function wrapper for ease of use\n\nThe `fibonacci()` function provides a clean, simple interface while being backed by a well-architected, extensible system.",
    "output_tokens": 2660
  },
  {
    "problem_id": "fibonacci",
    "problem_name": "Fibonacci",
    "prompt": "Write a function that returns the nth Fibonacci number.",
    "style": "simple",
    "response": "```python\ndef fibonacci(n):\n    if n <= 1:\n        return n\n    \n    a, b = 0, 1\n    for _ in range(2, n + 1):\n        a, b = b, a + b\n    \n    return b\n```\n\nThis is the most straightforward iterative solution. It handles the base cases (0 and 1) and uses two variables to track the previous two numbers, avoiding recursion overhead and keeping it simple with O(n) time and O(1) space complexity.",
    "output_tokens": 125
  },
  {
    "problem_id": "palindrome",
    "problem_name": "Palindrome Checker",
    "prompt": "Write a function that checks if a string is a palindrome.",
    "style": "pattern_brained",
    "response": "I'll create a well-architected palindrome checker using proper design patterns and SOLID principles.\n\n```python\nfrom abc import ABC, abstractmethod\nfrom typing import Protocol, runtime_checkable\nfrom enum import Enum\nimport re\n\n\nclass PalindromeStrategy(ABC):\n    \"\"\"Strategy interface for different palindrome checking algorithms.\"\"\"\n    \n    @abstractmethod\n    def is_palindrome(self, text: str) -> bool:\n        \"\"\"Check if the given text is a palindrome.\"\"\"\n        pass\n\n\nclass CaseSensitivity(Enum):\n    \"\"\"Enumeration for case sensitivity options.\"\"\"\n    SENSITIVE = \"sensitive\"\n    INSENSITIVE = \"insensitive\"\n\n\nclass CharacterFilter(Enum):\n    \"\"\"Enumeration for character filtering options.\"\"\"\n    ALL = \"all\"\n    ALPHANUMERIC_ONLY = \"alphanumeric_only\"\n\n\n@runtime_checkable\nclass TextNormalizer(Protocol):\n    \"\"\"Protocol for text normalization strategies.\"\"\"\n    \n    def normalize(self, text: str) -> str:\n        \"\"\"Normalize the input text according to specific rules.\"\"\"\n        ...\n\n\nclass StandardTextNormalizer:\n    \"\"\"Standard text normalizer that handles case and character filtering.\"\"\"\n    \n    def __init__(self, \n                 case_sensitivity: CaseSensitivity = CaseSensitivity.INSENSITIVE,\n                 character_filter: CharacterFilter = CharacterFilter.ALPHANUMERIC_ONLY):\n        self._case_sensitivity = case_sensitivity\n        self._character_filter = character_filter\n    \n    def normalize(self, text: str) -> str:\n        \"\"\"Normalize text based on configured options.\"\"\"\n        normalized = text\n        \n        if self._case_sensitivity == CaseSensitivity.INSENSITIVE:\n            normalized = normalized.lower()\n        \n        if self._character_filter == CharacterFilter.ALPHANUMERIC_ONLY:\n            normalized = re.sub(r'[^a-zA-Z0-9]', '', normalized)\n        \n        return normalized\n\n\nclass TwoPointerPalindromeStrategy(PalindromeStrategy):\n    \"\"\"Two-pointer algorithm strategy for palindrome checking.\"\"\"\n    \n    def __init__(self, normalizer: TextNormalizer):\n        self._normalizer = normalizer\n    \n    def is_palindrome(self, text: str) -> bool:\n        \"\"\"Check palindrome using two-pointer technique.\"\"\"\n        normalized = self._normalizer.normalize(text)\n        \n        if not normalized:\n            return True  # Empty string is considered a palindrome\n        \n        left, right = 0, len(normalized) - 1\n        \n        while left < right:\n            if normalized[left] != normalized[right]:\n                return False\n            left += 1\n            right -= 1\n        \n        return True\n\n\nclass ReversalPalindromeStrategy(PalindromeStrategy):\n    \"\"\"String reversal strategy for palindrome checking.\"\"\"\n    \n    def __init__(self, normalizer: TextNormalizer):\n        self._normalizer = normalizer\n    \n    def is_palindrome(self, text: str) -> bool:\n        \"\"\"Check palindrome by comparing with reversed string.\"\"\"\n        normalized = self._normalizer.normalize(text)\n        return normalized == normalized[::-1]\n\n\nclass RecursivePalindromeStrategy(PalindromeStrategy):\n    \"\"\"Recursive strategy for palindrome checking.\"\"\"\n    \n    def __init__(self, normalizer: TextNormalizer):\n        self._normalizer = normalizer\n    \n    def is_palindrome(self, text: str) -> bool:\n        \"\"\"Check palindrome using recursive approach.\"\"\"\n        normalized = self._normalizer.normalize(text)\n        return self._is_palindrome_recursive(normalized)\n    \n    def _is_palindrome_recursive(self, text: str) -> bool:\n        \"\"\"Recursive helper method.\"\"\"\n        if len(text) <= 1:\n            return True\n        \n        if text[0] != text[-1]:\n            return False\n        \n        return self._is_palindrome_recursive(text[1:-1])\n\n\nclass PalindromeStrategyFactory:\n    \"\"\"Factory for creating palindrome checking strategies.\"\"\"\n    \n    @staticmethod\n    def create_strategy(strategy_type: str, normalizer: TextNormalizer) -> PalindromeStrategy:\n        \"\"\"Create a palindrome strategy based on the specified type.\"\"\"\n        strategies = {\n            'two_pointer': TwoPointerPalindromeStrategy,\n            'reversal': ReversalPalindromeStrategy,\n            'recursive': RecursivePalindromeStrategy\n        }\n        \n        strategy_class = strategies.get(strategy_type.lower())\n        if not strategy_class:\n            raise ValueError(f\"Unknown strategy type: {strategy_type}\")\n        \n        return strategy_class(normalizer)\n\n\nclass PalindromeChecker:\n    \"\"\"Main palindrome checker class that uses the Strategy pattern.\"\"\"\n    \n    def __init__(self, strategy: PalindromeStrategy):\n        self._strategy = strategy\n    \n    def check(self, text: str) -> bool:\n        \"\"\"Check if the given text is a palindrome.\"\"\"\n        if not isinstance(text, str):\n            raise TypeError(\"Input must be a string\")\n        \n        return self._strategy.is_palindrome(text)\n    \n    def set_strategy(self, strategy: PalindromeStrategy) -> None:\n        \"\"\"Change the palindrome checking strategy at runtime.\"\"\"\n        self._strategy = strategy\n\n\nclass PalindromeCheckerBuilder:\n    \"\"\"Builder pattern for creating configured palindrome checkers.\"\"\"\n    \n    def __init__(self):\n        self._strategy_type = 'two_pointer'\n        self._case_sensitivity = CaseSensitivity.INSENSITIVE\n        self._character_filter = CharacterFilter.ALPHANUMERIC_ONLY\n    \n    def with_strategy(self, strategy_type: str) -> 'PalindromeCheckerBuilder':\n        \"\"\"Set the palindrome checking strategy.\"\"\"\n        self._strategy_type = strategy_type\n        return self\n    \n    def with_case_sensitivity(self, case_sensitivity: CaseSensitivity) -> 'PalindromeCheckerBuilder':\n        \"\"\"Set case sensitivity option.\"\"\"\n        self._case_sensitivity = case_sensitivity\n        return self\n    \n    def with_character_filter(self, character_filter: CharacterFilter) -> 'PalindromeCheckerBuilder':\n        \"\"\"Set character filtering option.\"\"\"\n        self._character_filter = character_filter\n        return self\n    \n    def build(self) -> PalindromeChecker:\n        \"\"\"Build the configured palindrome checker.\"\"\"\n        normalizer = StandardTextNormalizer(self._case_sensitivity, self._character_filter)\n        strategy = PalindromeStrategyFactory.create_strategy(self._strategy_type, normalizer)\n        return PalindromeChecker(strategy)\n\n\n# Convenience function with default configuration\ndef is_palindrome(text: str) -> bool:\n    \"\"\"\n    Simple function to check if a string is a palindrome using default settings.\n    \n    Args:\n        text: The string to check\n        \n    Returns:\n        bool: True if the string is a palindrome, False otherwise\n        \n    Raises:\n        TypeError: If input is not a string\n    \"\"\"\n    checker = (PalindromeCheckerBuilder()\n               .with_strategy('two_pointer')\n               .with_case_sensitivity(CaseSensitivity.INSENSITIVE)\n               .with_character_filter(CharacterFilter.ALPHANUMERIC_ONLY)\n               .build())\n    \n    return checker.check(text)\n\n\n# Example usage and demonstration\nif __name__ == \"__main__\":\n    # Simple usage with convenience function\n    print(is_palindrome(\"A man, a plan, a canal: Panama\"))  # True\n    print(is_palindrome(\"race a car\"))  # False\n    \n    # Advanced usage with custom configuration\n    strict_checker = (PalindromeCheckerBuilder()\n                     .with_strategy('recursive')\n                     .with_case_sensitivity(CaseSensitivity.SENSITIVE)\n                     .with_character_filter(CharacterFilter.ALL)\n                     .build())\n    \n    print(strict_checker.check(\"Aa\"))  # False (case sensitive)\n    \n    # Runtime strategy switching\n    checker = (PalindromeCheckerBuilder()\n              .with_strategy('reversal')\n              .build())\n    \n    print(checker.check(\"racecar\"))  # True\n    \n    # Switch to different strategy\n    normalizer = StandardTextNormalizer()\n    new_strategy = TwoPointerPalindromeStrategy(normalizer)\n    checker.set_strategy(new_strategy)\n    print(checker.check(\"Was it a car or a cat I saw?\"))  # True\n```\n\nThis implementation demonstrates several design patterns and architectural principles:\n\n## Design Patterns Used:\n\n1. **Strategy Pattern**: Different algorithms for palindrome checking (two-pointer, reversal, recursive)\n2. **Factory Pattern**: `PalindromeStrategyFactory` creates appropriate strategy instances\n3. **Builder Pattern**: `PalindromeCheckerBuilder` for flexible configuration\n4. **Protocol/Interface Segregation**: `TextNormalizer` protocol and `PalindromeStrategy` abstract base class\n\n## SOLID Principles:\n\n1. **Single Responsibility**: Each class has one clear purpose\n2. **Open/Closed**: Easy to add new strategies without modifying existing code\n3. **Liskov Substitution**: All strategies are interchangeable\n4. **Interface Segregation**: Clean, focused interfaces\n5. **Dependency Inversion**: High-level classes depend on abstractions\n\n## Key Features:\n\n- **Extensibility**: Easy to add new palindrome algorithms or normalization strategies\n- **Configurability**: Flexible options for case sensitivity and character filtering\n- **Runtime Strategy Switching**: Can change algorithms dynamically\n- **Type Safety**: Proper type hints and runtime checking\n- **Error Handling**: Appropriate exception handling\n- **Clean API**: Both simple function and advanced class-based interfaces\n\nThis architecture makes the code maintainable, testable, and extensible while providing a clean, easy-to-use interface.",
    "output_tokens": 2458
  },
  {
    "problem_id": "palindrome",
    "problem_name": "Palindrome Checker",
    "prompt": "Write a function that checks if a string is a palindrome.",
    "style": "simple",
    "response": "```python\ndef is_palindrome(s):\n    return s == s[::-1]\n```\n\nThat's it. Takes a string, compares it to its reverse. Returns `True` if they match, `False` otherwise.\n\nIf you need to ignore case and spaces (common palindrome requirement), here's the slightly longer version:\n\n```python\ndef is_palindrome(s):\n    s = s.lower().replace(' ', '')\n    return s == s[::-1]\n```",
    "output_tokens": 113
  },
  {
    "problem_id": "todo_list",
    "problem_name": "Todo List",
    "prompt": "Write a simple todo list application with add, remove, and list functionality.",
    "style": "pattern_brained",
    "response": "I'll create a well-architected todo list application using proper design patterns and SOLID principles. Here's the implementation:\n\n```python\nfrom abc import ABC, abstractmethod\nfrom typing import List, Optional, Dict, Any\nfrom dataclasses import dataclass, field\nfrom datetime import datetime\nimport json\nfrom enum import Enum\n\n\nclass TodoStatus(Enum):\n    PENDING = \"pending\"\n    COMPLETED = \"completed\"\n\n\n@dataclass\nclass TodoItem:\n    \"\"\"Value object representing a todo item.\"\"\"\n    id: str\n    title: str\n    description: str = \"\"\n    status: TodoStatus = TodoStatus.PENDING\n    created_at: datetime = field(default_factory=datetime.now)\n    completed_at: Optional[datetime] = None\n\n    def mark_completed(self) -> None:\n        \"\"\"Mark the todo item as completed.\"\"\"\n        self.status = TodoStatus.COMPLETED\n        self.completed_at = datetime.now()\n\n    def mark_pending(self) -> None:\n        \"\"\"Mark the todo item as pending.\"\"\"\n        self.status = TodoStatus.PENDING\n        self.completed_at = None\n\n    def to_dict(self) -> Dict[str, Any]:\n        \"\"\"Convert todo item to dictionary for serialization.\"\"\"\n        return {\n            'id': self.id,\n            'title': self.title,\n            'description': self.description,\n            'status': self.status.value,\n            'created_at': self.created_at.isoformat(),\n            'completed_at': self.completed_at.isoformat() if self.completed_at else None\n        }\n\n    @classmethod\n    def from_dict(cls, data: Dict[str, Any]) -> 'TodoItem':\n        \"\"\"Create todo item from dictionary.\"\"\"\n        return cls(\n            id=data['id'],\n            title=data['title'],\n            description=data.get('description', ''),\n            status=TodoStatus(data['status']),\n            created_at=datetime.fromisoformat(data['created_at']),\n            completed_at=datetime.fromisoformat(data['completed_at']) if data['completed_at'] else None\n        )\n\n\nclass TodoRepository(ABC):\n    \"\"\"Abstract repository for todo items.\"\"\"\n\n    @abstractmethod\n    def save(self, todo: TodoItem) -> None:\n        \"\"\"Save a todo item.\"\"\"\n        pass\n\n    @abstractmethod\n    def find_by_id(self, todo_id: str) -> Optional[TodoItem]:\n        \"\"\"Find a todo item by ID.\"\"\"\n        pass\n\n    @abstractmethod\n    def find_all(self) -> List[TodoItem]:\n        \"\"\"Find all todo items.\"\"\"\n        pass\n\n    @abstractmethod\n    def delete(self, todo_id: str) -> bool:\n        \"\"\"Delete a todo item by ID.\"\"\"\n        pass\n\n\nclass InMemoryTodoRepository(TodoRepository):\n    \"\"\"In-memory implementation of todo repository.\"\"\"\n\n    def __init__(self):\n        self._todos: Dict[str, TodoItem] = {}\n\n    def save(self, todo: TodoItem) -> None:\n        \"\"\"Save a todo item.\"\"\"\n        self._todos[todo.id] = todo\n\n    def find_by_id(self, todo_id: str) -> Optional[TodoItem]:\n        \"\"\"Find a todo item by ID.\"\"\"\n        return self._todos.get(todo_id)\n\n    def find_all(self) -> List[TodoItem]:\n        \"\"\"Find all todo items.\"\"\"\n        return list(self._todos.values())\n\n    def delete(self, todo_id: str) -> bool:\n        \"\"\"Delete a todo item by ID.\"\"\"\n        if todo_id in self._todos:\n            del self._todos[todo_id]\n            return True\n        return False\n\n\nclass FileTodoRepository(TodoRepository):\n    \"\"\"File-based implementation of todo repository.\"\"\"\n\n    def __init__(self, file_path: str):\n        self._file_path = file_path\n        self._todos: Dict[str, TodoItem] = self._load_todos()\n\n    def _load_todos(self) -> Dict[str, TodoItem]:\n        \"\"\"Load todos from file.\"\"\"\n        try:\n            with open(self._file_path, 'r') as f:\n                data = json.load(f)\n                return {\n                    todo_id: TodoItem.from_dict(todo_data)\n                    for todo_id, todo_data in data.items()\n                }\n        except (FileNotFoundError, json.JSONDecodeError):\n            return {}\n\n    def _save_todos(self) -> None:\n        \"\"\"Save todos to file.\"\"\"\n        data = {\n            todo_id: todo.to_dict()\n            for todo_id, todo in self._todos.items()\n        }\n        with open(self._file_path, 'w') as f:\n            json.dump(data, f, indent=2)\n\n    def save(self, todo: TodoItem) -> None:\n        \"\"\"Save a todo item.\"\"\"\n        self._todos[todo.id] = todo\n        self._save_todos()\n\n    def find_by_id(self, todo_id: str) -> Optional[TodoItem]:\n        \"\"\"Find a todo item by ID.\"\"\"\n        return self._todos.get(todo_id)\n\n    def find_all(self) -> List[TodoItem]:\n        \"\"\"Find all todo items.\"\"\"\n        return list(self._todos.values())\n\n    def delete(self, todo_id: str) -> bool:\n        \"\"\"Delete a todo item by ID.\"\"\"\n        if todo_id in self._todos:\n            del self._todos[todo_id]\n            self._save_todos()\n            return True\n        return False\n\n\nclass IdGenerator(ABC):\n    \"\"\"Abstract ID generator.\"\"\"\n\n    @abstractmethod\n    def generate(self) -> str:\n        \"\"\"Generate a unique ID.\"\"\"\n        pass\n\n\nclass UUIDGenerator(IdGenerator):\n    \"\"\"UUID-based ID generator.\"\"\"\n\n    def generate(self) -> str:\n        \"\"\"Generate a unique UUID.\"\"\"\n        import uuid\n        return str(uuid.uuid4())\n\n\nclass TodoService:\n    \"\"\"Service layer for todo operations.\"\"\"\n\n    def __init__(self, repository: TodoRepository, id_generator: IdGenerator):\n        self._repository = repository\n        self._id_generator = id_generator\n\n    def add_todo(self, title: str, description: str = \"\") -> TodoItem:\n        \"\"\"Add a new todo item.\"\"\"\n        if not title.strip():\n            raise ValueError(\"Todo title cannot be empty\")\n\n        todo_id = self._id_generator.generate()\n        todo = TodoItem(\n            id=todo_id,\n            title=title.strip(),\n            description=description.strip()\n        )\n        \n        self._repository.save(todo)\n        return todo\n\n    def remove_todo(self, todo_id: str) -> bool:\n        \"\"\"Remove a todo item by ID.\"\"\"\n        return self._repository.delete(todo_id)\n\n    def get_todo(self, todo_id: str) -> Optional[TodoItem]:\n        \"\"\"Get a todo item by ID.\"\"\"\n        return self._repository.find_by_id(todo_id)\n\n    def list_todos(self, status: Optional[TodoStatus] = None) -> List[TodoItem]:\n        \"\"\"List all todos, optionally filtered by status.\"\"\"\n        todos = self._repository.find_all()\n        \n        if status is not None:\n            todos = [todo for todo in todos if todo.status == status]\n        \n        # Sort by creation date\n        return sorted(todos, key=lambda x: x.created_at)\n\n    def complete_todo(self, todo_id: str) -> bool:\n        \"\"\"Mark a todo as completed.\"\"\"\n        todo = self._repository.find_by_id(todo_id)\n        if todo:\n            todo.mark_completed()\n            self._repository.save(todo)\n            return True\n        return False\n\n    def reopen_todo(self, todo_id: str) -> bool:\n        \"\"\"Mark a completed todo as pending.\"\"\"\n        todo = self._repository.find_by_id(todo_id)\n        if todo:\n            todo.mark_pending()\n            self._repository.save(todo)\n            return True\n        return False\n\n\nclass TodoFormatter(ABC):\n    \"\"\"Abstract formatter for todo items.\"\"\"\n\n    @abstractmethod\n    def format_todo(self, todo: TodoItem) -> str:\n        \"\"\"Format a single todo item.\"\"\"\n        pass\n\n    @abstractmethod\n    def format_todo_list(self, todos: List[TodoItem]) -> str:\n        \"\"\"Format a list of todo items.\"\"\"\n        pass\n\n\nclass SimpleTodoFormatter(TodoFormatter):\n    \"\"\"Simple text formatter for todo items.\"\"\"\n\n    def format_todo(self, todo: TodoItem) -> str:\n        \"\"\"Format a single todo item.\"\"\"\n        status_symbol = \"\u2713\" if todo.status == TodoStatus.COMPLETED else \"\u25cb\"\n        return f\"{status_symbol} [{todo.id[:8]}] {todo.title}\"\n\n    def format_todo_list(self, todos: List[TodoItem]) -> str:\n        \"\"\"Format a list of todo items.\"\"\"\n        if not todos:\n            return \"No todos found.\"\n        \n        formatted_todos = [self.format_todo(todo) for todo in todos]\n        return \"\\n\".join(formatted_todos)\n\n\nclass DetailedTodoFormatter(TodoFormatter):\n    \"\"\"Detailed formatter for todo items.\"\"\"\n\n    def format_todo(self, todo: TodoItem) -> str:\n        \"\"\"Format a single todo item with details.\"\"\"\n        status_symbol = \"\u2713\" if todo.status == TodoStatus.COMPLETED else \"\u25cb\"\n        lines = [\n            f\"{status_symbol} [{todo.id[:8]}] {todo.title}\",\n            f\"  Description: {todo.description or 'No description'}\",\n            f\"  Created: {todo.created_at.strftime('%Y-%m-%d %H:%M')}\"\n        ]\n        \n        if todo.completed_at:\n            lines.append(f\"  Completed: {todo.completed_at.strftime('%Y-%m-%d %H:%M')}\")\n        \n        return \"\\n\".join(lines)\n\n    def format_todo_list(self, todos: List[TodoItem]) -> str:\n        \"\"\"Format a list of todo items with details.\"\"\"\n        if not todos:\n            return \"No todos found.\"\n        \n        formatted_todos = [self.format_todo(todo) for todo in todos]\n        return \"\\n\\n\".join(formatted_todos)\n\n\nclass TodoApplication:\n    \"\"\"Main application class that orchestrates all components.\"\"\"\n\n    def __init__(\n        self,\n        service: TodoService,\n        formatter: TodoFormatter = None\n    ):\n        self._service = service\n        self._formatter = formatter or SimpleTodoFormatter()\n\n    def add_todo(self, title: str, description: str = \"\") -> str:\n        \"\"\"Add a new todo and return formatted result.\"\"\"\n        try:\n            todo = self._service.add_todo(title, description)\n            return f\"Added: {self._formatter.format_todo(todo)}\"\n        except ValueError as e:\n            return f\"Error: {e}\"\n\n    def remove_todo(self, todo_id: str) -> str:\n        \"\"\"Remove a todo and return result message.\"\"\"\n        if self._service.remove_todo(todo_id):\n            return f\"Removed todo with ID: {todo_id[:8]}\"\n        else:\n            return f\"Todo with ID {todo_id[:8]} not found\"\n\n    def list_todos(self, status: Optional[TodoStatus] = None) -> str:\n        \"\"\"List todos with optional status filter.\"\"\"\n        todos = self._service.list_todos(status)\n        \n        if status:\n            header = f\"{status.value.title()} Todos:\"\n        else:\n            header = \"All Todos:\"\n        \n        formatted_list = self._formatter.format_todo_list(todos)\n        return f\"{header}\\n{formatted_list}\"\n\n    def complete_todo(self, todo_id: str) -> str:\n        \"\"\"Complete a todo and return result message.\"\"\"\n        if self._service.complete_todo(todo_id):\n            return f\"Completed todo with ID: {todo_id[:8]}\"\n        else:\n            return f\"Todo with ID {todo_id[:8]} not found\"\n\n    def reopen_todo(self, todo_id: str) -> str:\n        \"\"\"Reopen a completed todo and return result message.\"\"\"\n        if self._service.reopen_todo(todo_id):\n            return f\"Reopened todo with ID: {todo_id[:8]}\"\n        else:\n            return f\"Todo with ID {todo_id[:8]} not found\"\n\n\n# Factory for creating configured application instances\nclass TodoApplicationFactory:\n    \"\"\"Factory for creating configured todo applications.\"\"\"\n\n    @staticmethod\n    def create_in_memory_app(formatter: TodoFormatter = None) -> TodoApplication:\n        \"\"\"Create an application with in-memory storage.\"\"\"\n        repository = InMemoryTodoRepository()\n        id_generator = UUIDGenerator()\n        service = TodoService(repository, id_generator)\n        return TodoApplication(service, formatter)\n\n    @staticmethod\n    def create_file_based_app(\n        file_path: str,\n        formatter: TodoFormatter = None\n    ) -> TodoApplication:\n        \"\"\"Create an application with file-based storage.\"\"\"\n        repository = FileTodoRepository(file_path)\n        id_generator = UUIDGenerator()\n        service = TodoService(repository, id_generator)\n        return TodoApplication(service, formatter)\n\n\n# Example usage and demo\ndef main():\n    \"\"\"Demonstrate the todo application.\"\"\"\n    print(\"=== Todo Application Demo ===\\n\")\n    \n    # Create application with detailed formatting\n    app = TodoApplicationFactory.create_in_memory_app(\n        DetailedTodoFormatter()\n    )\n    \n    # Add some todos\n    print(app.add_todo(\"Buy groceries\", \"Milk, bread, eggs\"))\n    print(app.add_todo(\"Write documentation\", \"Complete the API docs\"))\n    print(app.add_todo(\"Review code\"))\n    print()\n    \n    # List all todos\n    print(app.list_todos())\n    print()\n    \n    # Complete a todo (you'd need to use actual IDs in practice)\n    todos = app._service.list_todos()\n    if todos:\n        first_todo_id = todos[0].id\n        print(app.complete_todo(first_todo_id))\n        print()\n    \n    # List pending todos only\n    print(app.list_todos(TodoStatus.PENDING))\n    print()\n    \n    # List completed todos only\n    print(app.list_todos(TodoStatus.COMPLETED))\n\n\nif __name__ == \"__main__\":\n    main()\n```\n\nThis implementation demonstrates several key design patterns and architectural principles:\n\n## Design Patterns Used:\n\n1. **Repository Pattern**: `TodoRepository` provides an abstraction for data access\n2. **Factory Pattern**: `TodoApplicationFactory` creates configured instances\n3. **Strategy Pattern**: `TodoFormatter` allows different formatting strategies\n4. **Dependency Injection**: Components depend on abstractions, not concrete classes\n\n## SOLID Principles Applied:\n\n1. **Single Responsibility**: Each class has one clear purpose\n2. **Open/Closed**: Easy to extend with new formatters or repositories\n3. **Liskov Substitution**: Implementations are interchangeable\n4. **Interface Segregation**: Focused, minimal interfaces\n5. **Dependency Inversion**: High-level modules depend on abstractions\n\n## Key Features:\n\n- **Extensible storage**: Easily switch between in-memory and file storage\n- **Flexible formatting**: Multiple display formats available\n- **Proper error handling**: Validates inputs and handles edge cases\n- **Rich domain model**: TodoItem with status tracking and timestamps\n- **Clean separation**: Service layer separates business logic from presentation\n- **Type safety**: Full type hints throughout\n\nThe application can be easily extended with new storage backends, formatters, or business logic while maintaining clean architecture principles.",
    "output_tokens": 3812
  },
  {
    "problem_id": "todo_list",
    "problem_name": "Todo List",
    "prompt": "Write a simple todo list application with add, remove, and list functionality.",
    "style": "simple",
    "response": "Here's a simple todo list application in Python:\n\n```python\ntodos = []\n\ndef add_todo(task):\n    todos.append(task)\n    print(f\"Added: {task}\")\n\ndef remove_todo(index):\n    if 0 <= index < len(todos):\n        removed = todos.pop(index)\n        print(f\"Removed: {removed}\")\n    else:\n        print(\"Invalid task number\")\n\ndef list_todos():\n    if not todos:\n        print(\"No tasks\")\n        return\n    \n    for i, task in enumerate(todos):\n        print(f\"{i + 1}. {task}\")\n\ndef main():\n    while True:\n        print(\"\\n1. Add task\")\n        print(\"2. Remove task\") \n        print(\"3. List tasks\")\n        print(\"4. Quit\")\n        \n        choice = input(\"Choose option: \")\n        \n        if choice == \"1\":\n            task = input(\"Enter task: \")\n            add_todo(task)\n        elif choice == \"2\":\n            list_todos()\n            if todos:\n                try:\n                    index = int(input(\"Enter task number to remove: \")) - 1\n                    remove_todo(index)\n                except ValueError:\n                    print(\"Please enter a valid number\")\n        elif choice == \"3\":\n            list_todos()\n        elif choice == \"4\":\n            break\n        else:\n            print(\"Invalid option\")\n\nif __name__ == \"__main__\":\n    main()\n```\n\nThat's it. One file, basic functions, no classes or complex abstractions. It does exactly what you need: add tasks, remove tasks by number, and list all tasks.",
    "output_tokens": 397
  },
  {
    "problem_id": "calculator",
    "problem_name": "Calculator",
    "prompt": "Write a calculator that supports add, subtract, multiply, and divide operations.",
    "style": "pattern_brained",
    "response": "I'll create a well-architected calculator using proper design patterns and SOLID principles. Here's my implementation:\n\n```python\nfrom abc import ABC, abstractmethod\nfrom enum import Enum\nfrom typing import Dict, Type\nfrom decimal import Decimal, InvalidOperation\n\n\nclass OperationType(Enum):\n    \"\"\"Enumeration of supported operation types.\"\"\"\n    ADD = \"add\"\n    SUBTRACT = \"subtract\"\n    MULTIPLY = \"multiply\"\n    DIVIDE = \"divide\"\n\n\nclass CalculatorError(Exception):\n    \"\"\"Base exception for calculator-related errors.\"\"\"\n    pass\n\n\nclass InvalidOperationError(CalculatorError):\n    \"\"\"Raised when an invalid operation is requested.\"\"\"\n    pass\n\n\nclass DivisionByZeroError(CalculatorError):\n    \"\"\"Raised when attempting to divide by zero.\"\"\"\n    pass\n\n\nclass InvalidInputError(CalculatorError):\n    \"\"\"Raised when invalid input is provided.\"\"\"\n    pass\n\n\nclass Operation(ABC):\n    \"\"\"Abstract base class for mathematical operations.\"\"\"\n    \n    @abstractmethod\n    def execute(self, left_operand: Decimal, right_operand: Decimal) -> Decimal:\n        \"\"\"Execute the operation on two operands.\n        \n        Args:\n            left_operand: The left operand\n            right_operand: The right operand\n            \n        Returns:\n            The result of the operation\n            \n        Raises:\n            CalculatorError: If the operation cannot be performed\n        \"\"\"\n        pass\n    \n    @property\n    @abstractmethod\n    def symbol(self) -> str:\n        \"\"\"Return the symbol representing this operation.\"\"\"\n        pass\n\n\nclass AddOperation(Operation):\n    \"\"\"Implementation of addition operation.\"\"\"\n    \n    def execute(self, left_operand: Decimal, right_operand: Decimal) -> Decimal:\n        return left_operand + right_operand\n    \n    @property\n    def symbol(self) -> str:\n        return \"+\"\n\n\nclass SubtractOperation(Operation):\n    \"\"\"Implementation of subtraction operation.\"\"\"\n    \n    def execute(self, left_operand: Decimal, right_operand: Decimal) -> Decimal:\n        return left_operand - right_operand\n    \n    @property\n    def symbol(self) -> str:\n        return \"-\"\n\n\nclass MultiplyOperation(Operation):\n    \"\"\"Implementation of multiplication operation.\"\"\"\n    \n    def execute(self, left_operand: Decimal, right_operand: Decimal) -> Decimal:\n        return left_operand * right_operand\n    \n    @property\n    def symbol(self) -> str:\n        return \"*\"\n\n\nclass DivideOperation(Operation):\n    \"\"\"Implementation of division operation.\"\"\"\n    \n    def execute(self, left_operand: Decimal, right_operand: Decimal) -> Decimal:\n        if right_operand == 0:\n            raise DivisionByZeroError(\"Cannot divide by zero\")\n        return left_operand / right_operand\n    \n    @property\n    def symbol(self) -> str:\n        return \"/\"\n\n\nclass OperationFactory:\n    \"\"\"Factory class for creating operation instances.\"\"\"\n    \n    _operation_registry: Dict[OperationType, Type[Operation]] = {\n        OperationType.ADD: AddOperation,\n        OperationType.SUBTRACT: SubtractOperation,\n        OperationType.MULTIPLY: MultiplyOperation,\n        OperationType.DIVIDE: DivideOperation,\n    }\n    \n    @classmethod\n    def create_operation(cls, operation_type: OperationType) -> Operation:\n        \"\"\"Create an operation instance based on the operation type.\n        \n        Args:\n            operation_type: The type of operation to create\n            \n        Returns:\n            An instance of the requested operation\n            \n        Raises:\n            InvalidOperationError: If the operation type is not supported\n        \"\"\"\n        if operation_type not in cls._operation_registry:\n            raise InvalidOperationError(f\"Unsupported operation: {operation_type}\")\n        \n        operation_class = cls._operation_registry[operation_type]\n        return operation_class()\n    \n    @classmethod\n    def register_operation(cls, operation_type: OperationType, \n                          operation_class: Type[Operation]) -> None:\n        \"\"\"Register a new operation type (for extensibility).\n        \n        Args:\n            operation_type: The operation type to register\n            operation_class: The operation class to associate with the type\n        \"\"\"\n        cls._operation_registry[operation_type] = operation_class\n    \n    @classmethod\n    def get_supported_operations(cls) -> list[OperationType]:\n        \"\"\"Get a list of all supported operation types.\"\"\"\n        return list(cls._operation_registry.keys())\n\n\nclass InputValidator:\n    \"\"\"Validator for calculator inputs.\"\"\"\n    \n    @staticmethod\n    def validate_numeric_input(value: str) -> Decimal:\n        \"\"\"Validate and convert string input to Decimal.\n        \n        Args:\n            value: String representation of a number\n            \n        Returns:\n            Decimal representation of the input\n            \n        Raises:\n            InvalidInputError: If the input is not a valid number\n        \"\"\"\n        try:\n            return Decimal(str(value).strip())\n        except (InvalidOperation, ValueError) as e:\n            raise InvalidInputError(f\"Invalid numeric input: {value}\") from e\n\n\nclass CalculationResult:\n    \"\"\"Data class representing the result of a calculation.\"\"\"\n    \n    def __init__(self, left_operand: Decimal, operation_symbol: str, \n                 right_operand: Decimal, result: Decimal):\n        self.left_operand = left_operand\n        self.operation_symbol = operation_symbol\n        self.right_operand = right_operand\n        self.result = result\n    \n    def __str__(self) -> str:\n        return f\"{self.left_operand} {self.operation_symbol} {self.right_operand} = {self.result}\"\n    \n    def __repr__(self) -> str:\n        return (f\"CalculationResult(left_operand={self.left_operand}, \"\n                f\"operation_symbol='{self.operation_symbol}', \"\n                f\"right_operand={self.right_operand}, result={self.result})\")\n\n\nclass Calculator:\n    \"\"\"Main calculator class that orchestrates operations.\"\"\"\n    \n    def __init__(self, operation_factory: OperationFactory = None,\n                 input_validator: InputValidator = None):\n        \"\"\"Initialize the calculator with dependencies.\n        \n        Args:\n            operation_factory: Factory for creating operations (dependency injection)\n            input_validator: Validator for inputs (dependency injection)\n        \"\"\"\n        self._operation_factory = operation_factory or OperationFactory()\n        self._input_validator = input_validator or InputValidator()\n    \n    def calculate(self, left_operand: str, operation_type: OperationType, \n                 right_operand: str) -> CalculationResult:\n        \"\"\"Perform a calculation.\n        \n        Args:\n            left_operand: String representation of the left operand\n            operation_type: The type of operation to perform\n            right_operand: String representation of the right operand\n            \n        Returns:\n            CalculationResult containing the operation details and result\n            \n        Raises:\n            CalculatorError: If the calculation cannot be performed\n        \"\"\"\n        # Validate inputs\n        left_decimal = self._input_validator.validate_numeric_input(left_operand)\n        right_decimal = self._input_validator.validate_numeric_input(right_operand)\n        \n        # Create and execute operation\n        operation = self._operation_factory.create_operation(operation_type)\n        result = operation.execute(left_decimal, right_decimal)\n        \n        # Return structured result\n        return CalculationResult(\n            left_operand=left_decimal,\n            operation_symbol=operation.symbol,\n            right_operand=right_decimal,\n            result=result\n        )\n    \n    def get_supported_operations(self) -> list[OperationType]:\n        \"\"\"Get list of supported operations.\"\"\"\n        return self._operation_factory.get_supported_operations()\n\n\nclass CalculatorInterface:\n    \"\"\"Command-line interface for the calculator.\"\"\"\n    \n    def __init__(self, calculator: Calculator = None):\n        \"\"\"Initialize the interface.\n        \n        Args:\n            calculator: Calculator instance (dependency injection)\n        \"\"\"\n        self._calculator = calculator or Calculator()\n    \n    def run_interactive_session(self) -> None:\n        \"\"\"Run an interactive calculator session.\"\"\"\n        print(\"Welcome to the Calculator!\")\n        print(\"Supported operations: add, subtract, multiply, divide\")\n        print(\"Type 'quit' to exit\\n\")\n        \n        while True:\n            try:\n                # Get user input\n                left = input(\"Enter first number: \").strip()\n                if left.lower() == 'quit':\n                    break\n                \n                operation = input(\"Enter operation (add/subtract/multiply/divide): \").strip()\n                if operation.lower() == 'quit':\n                    break\n                \n                right = input(\"Enter second number: \").strip()\n                if right.lower() == 'quit':\n                    break\n                \n                # Map string to operation type\n                operation_mapping = {\n                    'add': OperationType.ADD,\n                    'subtract': OperationType.SUBTRACT,\n                    'multiply': OperationType.MULTIPLY,\n                    'divide': OperationType.DIVIDE\n                }\n                \n                if operation.lower() not in operation_mapping:\n                    print(f\"Error: Unsupported operation '{operation}'\\n\")\n                    continue\n                \n                operation_type = operation_mapping[operation.lower()]\n                \n                # Perform calculation\n                result = self._calculator.calculate(left, operation_type, right)\n                print(f\"Result: {result}\\n\")\n                \n            except CalculatorError as e:\n                print(f\"Calculator Error: {e}\\n\")\n            except KeyboardInterrupt:\n                print(\"\\nGoodbye!\")\n                break\n            except Exception as e:\n                print(f\"Unexpected error: {e}\\n\")\n\n\n# Example usage and demonstration\nif __name__ == \"__main__\":\n    # Example of direct usage\n    calc = Calculator()\n    \n    try:\n        # Perform some calculations\n        result1 = calc.calculate(\"10\", OperationType.ADD, \"5\")\n        print(result1)  # 10 + 5 = 15\n        \n        result2 = calc.calculate(\"20.5\", OperationType.MULTIPLY, \"3\")\n        print(result2)  # 20.5 * 3 = 61.5\n        \n        result3 = calc.calculate(\"15\", OperationType.DIVIDE, \"3\")\n        print(result3)  # 15 / 3 = 5\n        \n    except CalculatorError as e:\n        print(f\"Error: {e}\")\n    \n    # Run interactive session (uncomment to test)\n    # interface = CalculatorInterface(calc)\n    # interface.run_interactive_session()\n```\n\nThis implementation demonstrates several key design principles and patterns:\n\n## Design Patterns Used:\n\n1. **Strategy Pattern**: The `Operation` abstract base class with concrete implementations\n2. **Factory Pattern**: `OperationFactory` for creating operation instances\n3. **Dependency Injection**: Calculator accepts factory and validator dependencies\n4. **Command Pattern**: Operations encapsulate calculations as executable commands\n\n## SOLID Principles:\n\n1. **Single Responsibility**: Each class has one clear purpose\n2. **Open/Closed**: Easy to add new operations without modifying existing code\n3. **Liskov Substitution**: All operations can be used interchangeably\n4. **Interface Segregation**: Clean, focused interfaces\n5. **Dependency Inversion**: Calculator depends on abstractions, not concretions\n\n## Key Features:\n\n- **Extensibility**: Easy to add new operations by implementing `Operation` interface\n- **Error Handling**: Comprehensive exception hierarchy for different error types\n- **Input Validation**: Robust validation using `Decimal` for precision\n- **Separation of Concerns**: UI, business logic, and data validation are separate\n- **Type Safety**: Full type hints and enums for better IDE support\n- **Testability**: All dependencies can be mocked for unit testing\n\nThe calculator can be used programmatically or through the interactive interface, and new operations can be easily added by extending the `Operation` base class and registering them with the factory.",
    "output_tokens": 2993
  },
  {
    "problem_id": "calculator",
    "problem_name": "Calculator",
    "prompt": "Write a calculator that supports add, subtract, multiply, and divide operations.",
    "style": "simple",
    "response": "```python\ndef calculate(a, b, operation):\n    if operation == '+':\n        return a + b\n    elif operation == '-':\n        return a - b\n    elif operation == '*':\n        return a * b\n    elif operation == '/':\n        if b == 0:\n            return \"Error: Division by zero\"\n        return a / b\n    else:\n        return \"Error: Invalid operation\"\n\n# Simple interactive calculator\nwhile True:\n    try:\n        num1 = float(input(\"Enter first number: \"))\n        op = input(\"Enter operation (+, -, *, /) or 'q' to quit: \")\n        \n        if op == 'q':\n            break\n            \n        num2 = float(input(\"Enter second number: \"))\n        result = calculate(num1, num2, op)\n        print(f\"Result: {result}\")\n        \n    except ValueError:\n        print(\"Error: Please enter valid numbers\")\n    except KeyboardInterrupt:\n        break\n\nprint(\"Calculator closed.\")\n```\n\nThat's it. Simple function that does the math, simple loop that gets input and displays results. No classes, no complex error handling, just the core functionality that works.",
    "output_tokens": 282
  },
  {
    "problem_id": "user_validator",
    "problem_name": "User Validator",
    "prompt": "Write code to validate user registration data: email must be valid format, password must be at least 8 characters with a number, username must be alphanumeric.",
    "style": "pattern_brained",
    "response": "I'll create a well-architected user registration validation system using proper design patterns and SOLID principles.\n\n```python\nfrom abc import ABC, abstractmethod\nfrom typing import List, Dict, Any, Protocol\nfrom dataclasses import dataclass\nfrom enum import Enum\nimport re\n\n\nclass ValidationResult:\n    \"\"\"Value object to encapsulate validation results\"\"\"\n    \n    def __init__(self, is_valid: bool = True, errors: List[str] = None):\n        self.is_valid = is_valid\n        self.errors = errors or []\n    \n    def add_error(self, error: str) -> None:\n        self.errors.append(error)\n        self.is_valid = False\n    \n    def merge(self, other: 'ValidationResult') -> 'ValidationResult':\n        \"\"\"Merge two validation results\"\"\"\n        combined_errors = self.errors + other.errors\n        return ValidationResult(\n            is_valid=self.is_valid and other.is_valid,\n            errors=combined_errors\n        )\n\n\n@dataclass\nclass UserRegistrationData:\n    \"\"\"Data Transfer Object for user registration\"\"\"\n    email: str\n    password: str\n    username: str\n\n\nclass ValidationError(Exception):\n    \"\"\"Custom exception for validation errors\"\"\"\n    \n    def __init__(self, errors: List[str]):\n        self.errors = errors\n        super().__init__(f\"Validation failed: {', '.join(errors)}\")\n\n\nclass IValidator(Protocol):\n    \"\"\"Interface for all validators using Protocol (duck typing)\"\"\"\n    \n    def validate(self, value: str) -> ValidationResult:\n        \"\"\"Validate a value and return validation result\"\"\"\n        ...\n\n\nclass BaseValidator(ABC):\n    \"\"\"Abstract base class for validators implementing Template Method pattern\"\"\"\n    \n    @abstractmethod\n    def _perform_validation(self, value: str) -> ValidationResult:\n        \"\"\"Concrete validation logic to be implemented by subclasses\"\"\"\n        pass\n    \n    def validate(self, value: str) -> ValidationResult:\n        \"\"\"Template method that defines the validation algorithm\"\"\"\n        if not isinstance(value, str):\n            return ValidationResult(False, [\"Value must be a string\"])\n        \n        if not value or not value.strip():\n            return ValidationResult(False, [\"Value cannot be empty\"])\n        \n        return self._perform_validation(value.strip())\n\n\nclass EmailValidator(BaseValidator):\n    \"\"\"Validator for email format using regex strategy\"\"\"\n    \n    def __init__(self, pattern: str = None):\n        # Strategy pattern: allow different email validation patterns\n        self._pattern = pattern or r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$'\n        self._regex = re.compile(self._pattern)\n    \n    def _perform_validation(self, value: str) -> ValidationResult:\n        if not self._regex.match(value):\n            return ValidationResult(False, [\"Invalid email format\"])\n        return ValidationResult()\n\n\nclass PasswordValidator(BaseValidator):\n    \"\"\"Validator for password strength with configurable rules\"\"\"\n    \n    def __init__(self, min_length: int = 8, require_number: bool = True):\n        self._min_length = min_length\n        self._require_number = require_number\n    \n    def _perform_validation(self, value: str) -> ValidationResult:\n        result = ValidationResult()\n        \n        if len(value) < self._min_length:\n            result.add_error(f\"Password must be at least {self._min_length} characters long\")\n        \n        if self._require_number and not re.search(r'\\d', value):\n            result.add_error(\"Password must contain at least one number\")\n        \n        return result\n\n\nclass UsernameValidator(BaseValidator):\n    \"\"\"Validator for alphanumeric username\"\"\"\n    \n    def __init__(self, min_length: int = 1, max_length: int = 50):\n        self._min_length = min_length\n        self._max_length = max_length\n        self._pattern = re.compile(r'^[a-zA-Z0-9]+$')\n    \n    def _perform_validation(self, value: str) -> ValidationResult:\n        result = ValidationResult()\n        \n        if len(value) < self._min_length:\n            result.add_error(f\"Username must be at least {self._min_length} characters long\")\n        \n        if len(value) > self._max_length:\n            result.add_error(f\"Username cannot exceed {self._max_length} characters\")\n        \n        if not self._pattern.match(value):\n            result.add_error(\"Username must contain only alphanumeric characters\")\n        \n        return result\n\n\nclass ValidatorFactory:\n    \"\"\"Factory pattern for creating validators\"\"\"\n    \n    _validators = {\n        'email': EmailValidator,\n        'password': PasswordValidator,\n        'username': UsernameValidator,\n    }\n    \n    @classmethod\n    def create_validator(cls, validator_type: str, **kwargs) -> IValidator:\n        if validator_type not in cls._validators:\n            raise ValueError(f\"Unknown validator type: {validator_type}\")\n        \n        return cls._validators[validator_type](**kwargs)\n    \n    @classmethod\n    def register_validator(cls, name: str, validator_class: type) -> None:\n        \"\"\"Allow registration of custom validators\"\"\"\n        cls._validators[name] = validator_class\n\n\nclass UserRegistrationValidator:\n    \"\"\"Main validator class using Composite pattern to combine multiple validators\"\"\"\n    \n    def __init__(self, \n                 email_validator: IValidator = None,\n                 password_validator: IValidator = None,\n                 username_validator: IValidator = None):\n        # Dependency injection for flexibility and testability\n        self._email_validator = email_validator or ValidatorFactory.create_validator('email')\n        self._password_validator = password_validator or ValidatorFactory.create_validator('password')\n        self._username_validator = username_validator or ValidatorFactory.create_validator('username')\n    \n    def validate(self, user_data: UserRegistrationData) -> ValidationResult:\n        \"\"\"Validate all user registration data\"\"\"\n        email_result = self._email_validator.validate(user_data.email)\n        password_result = self._password_validator.validate(user_data.password)\n        username_result = self._username_validator.validate(user_data.username)\n        \n        # Combine all validation results\n        return email_result.merge(password_result).merge(username_result)\n    \n    def validate_and_raise(self, user_data: UserRegistrationData) -> None:\n        \"\"\"Validate and raise exception if invalid\"\"\"\n        result = self.validate(user_data)\n        if not result.is_valid:\n            raise ValidationError(result.errors)\n\n\nclass UserRegistrationService:\n    \"\"\"Service class that uses the validator - demonstrates Dependency Inversion\"\"\"\n    \n    def __init__(self, validator: UserRegistrationValidator = None):\n        self._validator = validator or UserRegistrationValidator()\n    \n    def register_user(self, email: str, password: str, username: str) -> Dict[str, Any]:\n        \"\"\"Register a user after validation\"\"\"\n        user_data = UserRegistrationData(\n            email=email,\n            password=password,\n            username=username\n        )\n        \n        validation_result = self._validator.validate(user_data)\n        \n        if not validation_result.is_valid:\n            return {\n                'success': False,\n                'errors': validation_result.errors\n            }\n        \n        # Here you would typically save to database\n        return {\n            'success': True,\n            'message': 'User registered successfully',\n            'user_data': {\n                'email': user_data.email,\n                'username': user_data.username\n                # Note: never return password in response\n            }\n        }\n\n\n# Example usage and testing\nif __name__ == \"__main__\":\n    # Example 1: Basic usage\n    service = UserRegistrationService()\n    \n    # Valid registration\n    result1 = service.register_user(\n        email=\"user@example.com\",\n        password=\"password123\",\n        username=\"john_doe\"  # This will fail - contains underscore\n    )\n    print(\"Result 1:\", result1)\n    \n    # Valid registration\n    result2 = service.register_user(\n        email=\"user@example.com\",\n        password=\"password123\",\n        username=\"johndoe\"\n    )\n    print(\"Result 2:\", result2)\n    \n    # Example 2: Custom validator configuration\n    custom_password_validator = ValidatorFactory.create_validator(\n        'password', \n        min_length=12, \n        require_number=True\n    )\n    \n    custom_validator = UserRegistrationValidator(\n        password_validator=custom_password_validator\n    )\n    \n    custom_service = UserRegistrationService(validator=custom_validator)\n    \n    result3 = custom_service.register_user(\n        email=\"user@example.com\",\n        password=\"short\",  # Will fail custom length requirement\n        username=\"johndoe\"\n    )\n    print(\"Result 3:\", result3)\n    \n    # Example 3: Using validation directly\n    validator = UserRegistrationValidator()\n    user_data = UserRegistrationData(\n        email=\"invalid-email\",\n        password=\"weak\",\n        username=\"user@123\"  # Contains @ symbol\n    )\n    \n    validation_result = validator.validate(user_data)\n    print(f\"Is valid: {validation_result.is_valid}\")\n    print(f\"Errors: {validation_result.errors}\")\n```\n\nThis implementation demonstrates several key design patterns and principles:\n\n## Design Patterns Used:\n\n1. **Strategy Pattern**: Different validation strategies can be plugged in\n2. **Factory Pattern**: `ValidatorFactory` creates validators\n3. **Template Method Pattern**: `BaseValidator` defines the validation algorithm structure\n4. **Composite Pattern**: `UserRegistrationValidator` combines multiple validators\n5. **Dependency Injection**: Services accept validators as dependencies\n\n## SOLID Principles:\n\n1. **Single Responsibility**: Each validator handles one type of validation\n2. **Open/Closed**: Easy to add new validators without modifying existing code\n3. **Liskov Substitution**: All validators can be used interchangeably\n4. **Interface Segregation**: Clean, focused interfaces\n5. **Dependency Inversion**: High-level modules depend on abstractions\n\n## Key Features:\n\n- **Extensible**: Easy to add new validation rules\n- **Configurable**: Validators accept configuration parameters\n- **Testable**: Dependencies can be mocked\n- **Reusable**: Validators can be used independently\n- **Error Handling**: Comprehensive error collection and reporting\n- **Type Safety**: Uses type hints and protocols\n\nThis architecture makes the code maintainable, testable, and easily extensible for future requirements.",
    "output_tokens": 2625
  },
  {
    "problem_id": "user_validator",
    "problem_name": "User Validator",
    "prompt": "Write code to validate user registration data: email must be valid format, password must be at least 8 characters with a number, username must be alphanumeric.",
    "style": "simple",
    "response": "```python\nimport re\n\ndef validate_registration(email, password, username):\n    errors = []\n    \n    # Validate email\n    if not re.match(r'^[^@]+@[^@]+\\.[^@]+$', email):\n        errors.append(\"Invalid email format\")\n    \n    # Validate password\n    if len(password) < 8:\n        errors.append(\"Password must be at least 8 characters\")\n    if not re.search(r'\\d', password):\n        errors.append(\"Password must contain at least one number\")\n    \n    # Validate username\n    if not username.isalnum():\n        errors.append(\"Username must be alphanumeric\")\n    \n    return len(errors) == 0, errors\n\n# Usage example:\nif __name__ == \"__main__\":\n    valid, errors = validate_registration(\"user@example.com\", \"password123\", \"user123\")\n    if valid:\n        print(\"Registration data is valid\")\n    else:\n        print(\"Validation errors:\")\n        for error in errors:\n            print(f\"- {error}\")\n```\n\nThat's it. One function that takes the three inputs, checks each requirement, and returns whether it's valid plus any error messages. No classes, no complex abstractions - just the validation logic you need.",
    "output_tokens": 307
  },
  {
    "problem_id": "file_processor",
    "problem_name": "File Processor",
    "prompt": "Write code that reads a CSV file and outputs JSON with the same data.",
    "style": "pattern_brained",
    "response": "I'll create a well-architected CSV to JSON converter following SOLID principles and design patterns. Here's a comprehensive solution:\n\n```python\nfrom abc import ABC, abstractmethod\nfrom typing import Dict, List, Any, Optional, Protocol\nimport csv\nimport json\nfrom pathlib import Path\nfrom dataclasses import dataclass\nfrom enum import Enum\nimport logging\n\n\n# Configuration and Data Models\n@dataclass\nclass ConversionConfig:\n    \"\"\"Configuration for CSV to JSON conversion.\"\"\"\n    delimiter: str = ','\n    quote_char: str = '\"'\n    skip_empty_rows: bool = True\n    encoding: str = 'utf-8'\n    \n    \nclass OutputFormat(Enum):\n    \"\"\"Supported output formats.\"\"\"\n    ARRAY_OF_OBJECTS = \"array_of_objects\"\n    OBJECT_WITH_ARRAYS = \"object_with_arrays\"\n\n\n# Interfaces and Protocols\nclass FileReader(Protocol):\n    \"\"\"Protocol for file reading operations.\"\"\"\n    \n    def read(self, file_path: Path, config: ConversionConfig) -> List[Dict[str, Any]]:\n        \"\"\"Read file and return structured data.\"\"\"\n        ...\n\n\nclass DataTransformer(Protocol):\n    \"\"\"Protocol for data transformation operations.\"\"\"\n    \n    def transform(self, data: List[Dict[str, Any]]) -> Any:\n        \"\"\"Transform data to desired format.\"\"\"\n        ...\n\n\nclass FileWriter(Protocol):\n    \"\"\"Protocol for file writing operations.\"\"\"\n    \n    def write(self, data: Any, output_path: Path) -> None:\n        \"\"\"Write data to file.\"\"\"\n        ...\n\n\n# Abstract Base Classes\nclass BaseReader(ABC):\n    \"\"\"Abstract base class for file readers.\"\"\"\n    \n    def __init__(self, logger: logging.Logger):\n        self._logger = logger\n    \n    @abstractmethod\n    def read(self, file_path: Path, config: ConversionConfig) -> List[Dict[str, Any]]:\n        \"\"\"Read and parse file content.\"\"\"\n        pass\n    \n    def _validate_file(self, file_path: Path) -> None:\n        \"\"\"Validate file existence and readability.\"\"\"\n        if not file_path.exists():\n            raise FileNotFoundError(f\"File not found: {file_path}\")\n        if not file_path.is_file():\n            raise ValueError(f\"Path is not a file: {file_path}\")\n\n\nclass BaseTransformer(ABC):\n    \"\"\"Abstract base class for data transformers.\"\"\"\n    \n    def __init__(self, logger: logging.Logger):\n        self._logger = logger\n    \n    @abstractmethod\n    def transform(self, data: List[Dict[str, Any]]) -> Any:\n        \"\"\"Transform data structure.\"\"\"\n        pass\n\n\nclass BaseWriter(ABC):\n    \"\"\"Abstract base class for file writers.\"\"\"\n    \n    def __init__(self, logger: logging.Logger):\n        self._logger = logger\n    \n    @abstractmethod\n    def write(self, data: Any, output_path: Path) -> None:\n        \"\"\"Write data to output file.\"\"\"\n        pass\n\n\n# Concrete Implementations\nclass CSVReader(BaseReader):\n    \"\"\"Concrete implementation for reading CSV files.\"\"\"\n    \n    def read(self, file_path: Path, config: ConversionConfig) -> List[Dict[str, Any]]:\n        \"\"\"Read CSV file and return list of dictionaries.\"\"\"\n        self._validate_file(file_path)\n        self._logger.info(f\"Reading CSV file: {file_path}\")\n        \n        data = []\n        try:\n            with open(file_path, 'r', encoding=config.encoding, newline='') as file:\n                reader = csv.DictReader(\n                    file,\n                    delimiter=config.delimiter,\n                    quotechar=config.quote_char\n                )\n                \n                for row_num, row in enumerate(reader, start=2):  # Start at 2 for header\n                    if config.skip_empty_rows and not any(row.values()):\n                        self._logger.debug(f\"Skipping empty row {row_num}\")\n                        continue\n                    \n                    # Clean up the row data\n                    cleaned_row = self._clean_row_data(row)\n                    data.append(cleaned_row)\n                    \n        except Exception as e:\n            self._logger.error(f\"Error reading CSV file: {e}\")\n            raise\n        \n        self._logger.info(f\"Successfully read {len(data)} rows\")\n        return data\n    \n    def _clean_row_data(self, row: Dict[str, str]) -> Dict[str, Any]:\n        \"\"\"Clean and convert row data types where possible.\"\"\"\n        cleaned = {}\n        for key, value in row.items():\n            if value is None:\n                cleaned[key] = None\n            elif value.strip() == '':\n                cleaned[key] = None\n            else:\n                # Try to convert to number if possible\n                cleaned[key] = self._convert_value(value.strip())\n        return cleaned\n    \n    def _convert_value(self, value: str) -> Any:\n        \"\"\"Attempt to convert string values to appropriate types.\"\"\"\n        if value.lower() in ('true', 'false'):\n            return value.lower() == 'true'\n        \n        # Try integer conversion\n        try:\n            if '.' not in value and 'e' not in value.lower():\n                return int(value)\n        except ValueError:\n            pass\n        \n        # Try float conversion\n        try:\n            return float(value)\n        except ValueError:\n            pass\n        \n        return value\n\n\nclass ArrayOfObjectsTransformer(BaseTransformer):\n    \"\"\"Transform data to array of objects format.\"\"\"\n    \n    def transform(self, data: List[Dict[str, Any]]) -> List[Dict[str, Any]]:\n        \"\"\"Return data as-is (already in array of objects format).\"\"\"\n        self._logger.info(f\"Transforming {len(data)} records to array of objects format\")\n        return data\n\n\nclass ObjectWithArraysTransformer(BaseTransformer):\n    \"\"\"Transform data to object with arrays format.\"\"\"\n    \n    def transform(self, data: List[Dict[str, Any]]) -> Dict[str, List[Any]]:\n        \"\"\"Convert array of objects to object with arrays.\"\"\"\n        self._logger.info(f\"Transforming {len(data)} records to object with arrays format\")\n        \n        if not data:\n            return {}\n        \n        result = {}\n        # Initialize arrays for each column\n        for key in data[0].keys():\n            result[key] = []\n        \n        # Populate arrays\n        for row in data:\n            for key, value in row.items():\n                result[key].append(value)\n        \n        return result\n\n\nclass JSONWriter(BaseWriter):\n    \"\"\"Concrete implementation for writing JSON files.\"\"\"\n    \n    def write(self, data: Any, output_path: Path) -> None:\n        \"\"\"Write data to JSON file.\"\"\"\n        self._logger.info(f\"Writing JSON file: {output_path}\")\n        \n        try:\n            # Ensure output directory exists\n            output_path.parent.mkdir(parents=True, exist_ok=True)\n            \n            with open(output_path, 'w', encoding='utf-8') as file:\n                json.dump(data, file, indent=2, ensure_ascii=False)\n                \n            self._logger.info(f\"Successfully wrote JSON file: {output_path}\")\n            \n        except Exception as e:\n            self._logger.error(f\"Error writing JSON file: {e}\")\n            raise\n\n\n# Factory Pattern\nclass TransformerFactory:\n    \"\"\"Factory for creating data transformers.\"\"\"\n    \n    @staticmethod\n    def create_transformer(output_format: OutputFormat, logger: logging.Logger) -> DataTransformer:\n        \"\"\"Create transformer based on output format.\"\"\"\n        transformers = {\n            OutputFormat.ARRAY_OF_OBJECTS: ArrayOfObjectsTransformer,\n            OutputFormat.OBJECT_WITH_ARRAYS: ObjectWithArraysTransformer,\n        }\n        \n        transformer_class = transformers.get(output_format)\n        if not transformer_class:\n            raise ValueError(f\"Unsupported output format: {output_format}\")\n        \n        return transformer_class(logger)\n\n\n# Main Service Class (Facade Pattern)\nclass CSVToJSONConverter:\n    \"\"\"Main service class that orchestrates the conversion process.\"\"\"\n    \n    def __init__(\n        self,\n        reader: Optional[FileReader] = None,\n        writer: Optional[FileWriter] = None,\n        logger: Optional[logging.Logger] = None\n    ):\n        \"\"\"Initialize converter with dependencies.\"\"\"\n        self._logger = logger or self._setup_default_logger()\n        self._reader = reader or CSVReader(self._logger)\n        self._writer = writer or JSONWriter(self._logger)\n    \n    def convert(\n        self,\n        input_path: Path,\n        output_path: Path,\n        config: Optional[ConversionConfig] = None,\n        output_format: OutputFormat = OutputFormat.ARRAY_OF_OBJECTS\n    ) -> None:\n        \"\"\"Convert CSV file to JSON.\"\"\"\n        config = config or ConversionConfig()\n        \n        self._logger.info(\"Starting CSV to JSON conversion\")\n        self._logger.info(f\"Input: {input_path}, Output: {output_path}\")\n        \n        try:\n            # Read CSV data\n            data = self._reader.read(input_path, config)\n            \n            # Transform data\n            transformer = TransformerFactory.create_transformer(output_format, self._logger)\n            transformed_data = transformer.transform(data)\n            \n            # Write JSON data\n            self._writer.write(transformed_data, output_path)\n            \n            self._logger.info(\"Conversion completed successfully\")\n            \n        except Exception as e:\n            self._logger.error(f\"Conversion failed: {e}\")\n            raise\n    \n    def _setup_default_logger(self) -> logging.Logger:\n        \"\"\"Set up default logger configuration.\"\"\"\n        logger = logging.getLogger(__name__)\n        if not logger.handlers:\n            handler = logging.StreamHandler()\n            formatter = logging.Formatter(\n                '%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n            )\n            handler.setFormatter(formatter)\n            logger.addHandler(handler)\n            logger.setLevel(logging.INFO)\n        return logger\n\n\n# Usage Example and CLI Interface\ndef main():\n    \"\"\"Main function demonstrating usage.\"\"\"\n    import argparse\n    \n    parser = argparse.ArgumentParser(description='Convert CSV files to JSON')\n    parser.add_argument('input_file', type=str, help='Input CSV file path')\n    parser.add_argument('output_file', type=str, help='Output JSON file path')\n    parser.add_argument('--format', type=str, choices=['array', 'object'], \n                       default='array', help='Output format')\n    parser.add_argument('--delimiter', type=str, default=',', help='CSV delimiter')\n    parser.add_argument('--encoding', type=str, default='utf-8', help='File encoding')\n    parser.add_argument('--verbose', '-v', action='store_true', help='Verbose logging')\n    \n    args = parser.parse_args()\n    \n    # Setup logging\n    logging.basicConfig(\n        level=logging.DEBUG if args.verbose else logging.INFO,\n        format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n    )\n    \n    # Configure conversion\n    config = ConversionConfig(\n        delimiter=args.delimiter,\n        encoding=args.encoding\n    )\n    \n    output_format = (\n        OutputFormat.ARRAY_OF_OBJECTS if args.format == 'array' \n        else OutputFormat.OBJECT_WITH_ARRAYS\n    )\n    \n    # Perform conversion\n    converter = CSVToJSONConverter()\n    converter.convert(\n        Path(args.input_file),\n        Path(args.output_file),\n        config,\n        output_format\n    )\n\n\n# Example usage as a library\nif __name__ == \"__main__\":\n    # Example 1: Basic usage\n    converter = CSVToJSONConverter()\n    converter.convert(\n        Path(\"input.csv\"),\n        Path(\"output.json\")\n    )\n    \n    # Example 2: Custom configuration\n    config = ConversionConfig(\n        delimiter=';',\n        encoding='utf-8',\n        skip_empty_rows=True\n    )\n    \n    converter.convert(\n        Path(\"data.csv\"),\n        Path(\"data.json\"),\n        config,\n        OutputFormat.OBJECT_WITH_ARRAYS\n    )\n    \n    # Example 3: With custom logger\n    logger = logging.getLogger(\"csv_converter\")\n    converter = CSVToJSONConverter(logger=logger)\n    converter.convert(\n        Path(\"input.csv\"),\n        Path(\"output.json\")\n    )\n```\n\nThis implementation demonstrates several key design patterns and principles:\n\n## Design Patterns Used:\n1. **Factory Pattern**: `TransformerFactory` creates appropriate transformers\n2. **Strategy Pattern**: Different transformation strategies via `DataTransformer` protocol\n3. **Facade Pattern**: `CSVToJSONConverter` provides simple interface to complex subsystem\n4. **Template Method**: Base classes define structure, concrete classes implement details\n\n## SOLID Principles:\n1. **Single Responsibility**: Each class has one clear purpose\n2. **Open/Closed**: Easy to extend with new readers, transformers, or writers\n3. **Liskov Substitution**: All implementations can be substituted for their abstractions\n4. **Interface Segregation**: Protocols define focused interfaces\n5. **Dependency Inversion**: High-level modules depend on abstractions\n\n## Key Features:\n- **Extensible**: Easy to add new input formats, output formats, or transformation strategies\n- **Configurable**: Comprehensive configuration options\n- **Type-safe**: Full type hints throughout\n- **Error handling**: Comprehensive error handling and logging\n- **Data type conversion**: Automatic conversion of strings to appropriate types\n- **Multiple output formats**: Array of objects or object with arrays\n- **CLI interface**: Can be used as command-line tool\n- **Library interface**: Can be imported and used programmatically\n\nThe code is production-ready with proper separation of concerns, dependency injection, and comprehensive error handling.",
    "output_tokens": 3461
  },
  {
    "problem_id": "file_processor",
    "problem_name": "File Processor",
    "prompt": "Write code that reads a CSV file and outputs JSON with the same data.",
    "style": "simple",
    "response": "```python\nimport csv\nimport json\n\ndef csv_to_json(csv_file, json_file):\n    with open(csv_file, 'r') as f:\n        reader = csv.DictReader(f)\n        data = list(reader)\n    \n    with open(json_file, 'w') as f:\n        json.dump(data, f, indent=2)\n\n# Usage\ncsv_to_json('input.csv', 'output.json')\n```\n\nThat's it. This reads a CSV file and writes the exact same data as JSON. Each CSV row becomes a JSON object, and the column headers become the object keys.",
    "output_tokens": 153
  },
  {
    "problem_id": "rate_limiter",
    "problem_name": "Rate Limiter",
    "prompt": "Write a rate limiter that allows max N requests per minute for a given user ID.",
    "style": "pattern_brained",
    "response": "I'll create a well-architected rate limiter using design patterns and SOLID principles. Here's a production-quality implementation:\n\n```python\nfrom abc import ABC, abstractmethod\nfrom typing import Dict, Optional, Protocol\nfrom dataclasses import dataclass\nfrom datetime import datetime, timedelta\nimport threading\nfrom collections import deque\nimport time\nfrom enum import Enum\n\n\nclass RateLimitResult(Enum):\n    \"\"\"Enumeration for rate limit check results.\"\"\"\n    ALLOWED = \"allowed\"\n    DENIED = \"denied\"\n\n\n@dataclass(frozen=True)\nclass RateLimitConfig:\n    \"\"\"Configuration for rate limiting.\"\"\"\n    max_requests: int\n    time_window_minutes: int\n    \n    def __post_init__(self):\n        if self.max_requests <= 0:\n            raise ValueError(\"max_requests must be positive\")\n        if self.time_window_minutes <= 0:\n            raise ValueError(\"time_window_minutes must be positive\")\n\n\n@dataclass(frozen=True)\nclass RateLimitResponse:\n    \"\"\"Response from rate limit check.\"\"\"\n    result: RateLimitResult\n    remaining_requests: int\n    reset_time: datetime\n    retry_after_seconds: Optional[int] = None\n\n\nclass TimeProvider(Protocol):\n    \"\"\"Protocol for time providers to enable testing.\"\"\"\n    \n    def now(self) -> datetime:\n        \"\"\"Get current datetime.\"\"\"\n        ...\n\n\nclass SystemTimeProvider:\n    \"\"\"System time provider implementation.\"\"\"\n    \n    def now(self) -> datetime:\n        return datetime.utcnow()\n\n\nclass RateLimitStorage(ABC):\n    \"\"\"Abstract base class for rate limit storage backends.\"\"\"\n    \n    @abstractmethod\n    def get_request_timestamps(self, user_id: str) -> deque:\n        \"\"\"Get request timestamps for a user.\"\"\"\n        pass\n    \n    @abstractmethod\n    def add_request_timestamp(self, user_id: str, timestamp: datetime) -> None:\n        \"\"\"Add a request timestamp for a user.\"\"\"\n        pass\n    \n    @abstractmethod\n    def cleanup_old_timestamps(self, user_id: str, cutoff_time: datetime) -> None:\n        \"\"\"Remove timestamps older than cutoff time.\"\"\"\n        pass\n\n\nclass InMemoryRateLimitStorage(RateLimitStorage):\n    \"\"\"In-memory storage implementation for rate limiting.\"\"\"\n    \n    def __init__(self):\n        self._storage: Dict[str, deque] = {}\n        self._lock = threading.RLock()\n    \n    def get_request_timestamps(self, user_id: str) -> deque:\n        with self._lock:\n            return self._storage.get(user_id, deque())\n    \n    def add_request_timestamp(self, user_id: str, timestamp: datetime) -> None:\n        with self._lock:\n            if user_id not in self._storage:\n                self._storage[user_id] = deque()\n            self._storage[user_id].append(timestamp)\n    \n    def cleanup_old_timestamps(self, user_id: str, cutoff_time: datetime) -> None:\n        with self._lock:\n            if user_id not in self._storage:\n                return\n            \n            timestamps = self._storage[user_id]\n            # Remove timestamps older than cutoff_time\n            while timestamps and timestamps[0] < cutoff_time:\n                timestamps.popleft()\n            \n            # Clean up empty entries\n            if not timestamps:\n                del self._storage[user_id]\n\n\nclass RateLimitStrategy(ABC):\n    \"\"\"Abstract strategy for rate limiting algorithms.\"\"\"\n    \n    @abstractmethod\n    def is_request_allowed(\n        self, \n        user_id: str, \n        config: RateLimitConfig,\n        current_time: datetime\n    ) -> RateLimitResponse:\n        \"\"\"Check if request is allowed and return response.\"\"\"\n        pass\n\n\nclass SlidingWindowRateLimitStrategy(RateLimitStrategy):\n    \"\"\"Sliding window rate limiting strategy.\"\"\"\n    \n    def __init__(self, storage: RateLimitStorage, time_provider: TimeProvider):\n        self._storage = storage\n        self._time_provider = time_provider\n    \n    def is_request_allowed(\n        self, \n        user_id: str, \n        config: RateLimitConfig,\n        current_time: datetime\n    ) -> RateLimitResponse:\n        \"\"\"Check if request is allowed using sliding window algorithm.\"\"\"\n        window_start = current_time - timedelta(minutes=config.time_window_minutes)\n        \n        # Clean up old timestamps\n        self._storage.cleanup_old_timestamps(user_id, window_start)\n        \n        # Get current timestamps in window\n        timestamps = self._storage.get_request_timestamps(user_id)\n        current_request_count = len(timestamps)\n        \n        # Check if request is allowed\n        if current_request_count >= config.max_requests:\n            # Find when the oldest request will expire\n            oldest_timestamp = timestamps[0] if timestamps else current_time\n            reset_time = oldest_timestamp + timedelta(minutes=config.time_window_minutes)\n            retry_after = int((reset_time - current_time).total_seconds())\n            \n            return RateLimitResponse(\n                result=RateLimitResult.DENIED,\n                remaining_requests=0,\n                reset_time=reset_time,\n                retry_after_seconds=max(0, retry_after)\n            )\n        \n        # Request is allowed, add timestamp\n        self._storage.add_request_timestamp(user_id, current_time)\n        remaining_requests = config.max_requests - current_request_count - 1\n        reset_time = current_time + timedelta(minutes=config.time_window_minutes)\n        \n        return RateLimitResponse(\n            result=RateLimitResult.ALLOWED,\n            remaining_requests=remaining_requests,\n            reset_time=reset_time\n        )\n\n\nclass RateLimiterFactory:\n    \"\"\"Factory for creating rate limiters with different configurations.\"\"\"\n    \n    @staticmethod\n    def create_sliding_window_rate_limiter(\n        storage: Optional[RateLimitStorage] = None,\n        time_provider: Optional[TimeProvider] = None\n    ) -> 'RateLimiter':\n        \"\"\"Create a sliding window rate limiter.\"\"\"\n        storage = storage or InMemoryRateLimitStorage()\n        time_provider = time_provider or SystemTimeProvider()\n        strategy = SlidingWindowRateLimitStrategy(storage, time_provider)\n        return RateLimiter(strategy, time_provider)\n    \n    @staticmethod\n    def create_in_memory_rate_limiter() -> 'RateLimiter':\n        \"\"\"Create an in-memory rate limiter with default configuration.\"\"\"\n        return RateLimiterFactory.create_sliding_window_rate_limiter()\n\n\nclass RateLimiter:\n    \"\"\"Main rate limiter class that uses strategy pattern.\"\"\"\n    \n    def __init__(self, strategy: RateLimitStrategy, time_provider: TimeProvider):\n        self._strategy = strategy\n        self._time_provider = time_provider\n        self._default_config = RateLimitConfig(max_requests=60, time_window_minutes=1)\n    \n    def check_rate_limit(\n        self, \n        user_id: str, \n        config: Optional[RateLimitConfig] = None\n    ) -> RateLimitResponse:\n        \"\"\"Check if a request is within rate limits.\"\"\"\n        if not user_id:\n            raise ValueError(\"user_id cannot be empty\")\n        \n        config = config or self._default_config\n        current_time = self._time_provider.now()\n        \n        return self._strategy.is_request_allowed(user_id, config, current_time)\n    \n    def is_allowed(self, user_id: str, config: Optional[RateLimitConfig] = None) -> bool:\n        \"\"\"Simple boolean check for rate limiting.\"\"\"\n        response = self.check_rate_limit(user_id, config)\n        return response.result == RateLimitResult.ALLOWED\n\n\n# Usage example and demonstration\ndef main():\n    \"\"\"Demonstrate the rate limiter usage.\"\"\"\n    \n    # Create rate limiter using factory\n    rate_limiter = RateLimiterFactory.create_in_memory_rate_limiter()\n    \n    # Configure for 5 requests per minute\n    config = RateLimitConfig(max_requests=5, time_window_minutes=1)\n    \n    user_id = \"user123\"\n    \n    print(\"Rate Limiter Demo\")\n    print(f\"Configuration: {config.max_requests} requests per {config.time_window_minutes} minute(s)\")\n    print(\"-\" * 50)\n    \n    # Simulate requests\n    for i in range(8):\n        response = rate_limiter.check_rate_limit(user_id, config)\n        print(f\"Request {i+1}: {response.result.value}\")\n        print(f\"  Remaining: {response.remaining_requests}\")\n        print(f\"  Reset time: {response.reset_time}\")\n        if response.retry_after_seconds:\n            print(f\"  Retry after: {response.retry_after_seconds} seconds\")\n        print()\n        \n        # Small delay between requests\n        time.sleep(0.1)\n\n\nif __name__ == \"__main__\":\n    main()\n```\n\nHere's also a comprehensive test suite to demonstrate the functionality:\n\n```python\nimport unittest\nfrom datetime import datetime, timedelta\nfrom unittest.mock import Mock\n\n\nclass MockTimeProvider:\n    \"\"\"Mock time provider for testing.\"\"\"\n    \n    def __init__(self, start_time: datetime):\n        self._current_time = start_time\n    \n    def now(self) -> datetime:\n        return self._current_time\n    \n    def advance_time(self, minutes: int):\n        \"\"\"Advance time by specified minutes.\"\"\"\n        self._current_time += timedelta(minutes=minutes)\n\n\nclass TestRateLimiter(unittest.TestCase):\n    \"\"\"Test cases for the rate limiter.\"\"\"\n    \n    def setUp(self):\n        self.start_time = datetime(2023, 1, 1, 12, 0, 0)\n        self.mock_time_provider = MockTimeProvider(self.start_time)\n        self.rate_limiter = RateLimiterFactory.create_sliding_window_rate_limiter(\n            time_provider=self.mock_time_provider\n        )\n        self.config = RateLimitConfig(max_requests=3, time_window_minutes=1)\n    \n    def test_allows_requests_within_limit(self):\n        \"\"\"Test that requests within limit are allowed.\"\"\"\n        user_id = \"user1\"\n        \n        for i in range(3):\n            response = self.rate_limiter.check_rate_limit(user_id, self.config)\n            self.assertEqual(response.result, RateLimitResult.ALLOWED)\n            self.assertEqual(response.remaining_requests, 2 - i)\n    \n    def test_denies_requests_over_limit(self):\n        \"\"\"Test that requests over limit are denied.\"\"\"\n        user_id = \"user1\"\n        \n        # Use up the limit\n        for _ in range(3):\n            self.rate_limiter.check_rate_limit(user_id, self.config)\n        \n        # Next request should be denied\n        response = self.rate_limiter.check_rate_limit(user_id, self.config)\n        self.assertEqual(response.result, RateLimitResult.DENIED)\n        self.assertEqual(response.remaining_requests, 0)\n        self.assertIsNotNone(response.retry_after_seconds)\n    \n    def test_sliding_window_resets(self):\n        \"\"\"Test that sliding window resets after time passes.\"\"\"\n        user_id = \"user1\"\n        \n        # Use up the limit\n        for _ in range(3):\n            self.rate_limiter.check_rate_limit(user_id, self.config)\n        \n        # Should be denied\n        response = self.rate_limiter.check_rate_limit(user_id, self.config)\n        self.assertEqual(response.result, RateLimitResult.DENIED)\n        \n        # Advance time past window\n        self.mock_time_provider.advance_time(2)\n        \n        # Should be allowed again\n        response = self.rate_limiter.check_rate_limit(user_id, self.config)\n        self.assertEqual(response.result, RateLimitResult.ALLOWED)\n    \n    def test_different_users_independent_limits(self):\n        \"\"\"Test that different users have independent rate limits.\"\"\"\n        # User 1 uses up limit\n        for _ in range(3):\n            self.rate_limiter.check_rate_limit(\"user1\", self.config)\n        \n        # User 1 should be denied\n        response1 = self.rate_limiter.check_rate_limit(\"user1\", self.config)\n        self.assertEqual(response1.result, RateLimitResult.DENIED)\n        \n        # User 2 should still be allowed\n        response2 = self.rate_limiter.check_rate_limit(\"user2\", self.config)\n        self.assertEqual(response2.result, RateLimitResult.ALLOWED)\n    \n    def test_invalid_user_id_raises_exception(self):\n        \"\"\"Test that invalid user ID raises exception.\"\"\"\n        with self.assertRaises(ValueError):\n            self.rate_limiter.check_rate_limit(\"\", self.config)\n    \n    def test_invalid_config_raises_exception(self):\n        \"\"\"Test that invalid configuration raises exception.\"\"\"\n        with self.assertRaises(ValueError):\n            RateLimitConfig(max_requests=0, time_window_minutes=1)\n        \n        with self.assertRaises(ValueError):\n            RateLimitConfig(max_requests=1, time_window_minutes=0)\n\n\nif __name__ == \"__main__\":\n    # Run the main demo\n    print(\"Running Rate Limiter Demo...\")\n    main()\n    \n    print(\"\\n\" + \"=\"*50)\n    print(\"Running Unit Tests...\")\n    unittest.main(argv=[''], exit=False, verbosity=2)\n```\n\n## Key Design Patterns and Principles Used:\n\n1. **Strategy Pattern**: `RateLimitStrategy` allows different rate limiting algorithms\n2. **Factory Pattern**: `RateLimiterFactory` creates configured instances\n3. **Protocol/Interface Segregation**: `TimeProvider` and `RateLimitStorage` protocols\n4. **Dependency Injection**: Dependencies injected through constructors\n5. **Single Responsibility**: Each class has one clear purpose\n6. **Open/Closed Principle**: Easy to extend with new strategies or storage backends\n7. **Configuration Object**: `RateLimitConfig` encapsulates configuration\n8. **Value Objects**: Immutable data classes for configuration and responses\n9. **Thread Safety**: Proper locking in storage implementation\n\n## Features:\n\n- **Configurable**: Different limits and time windows per use case\n- **Thread-safe**: Safe for concurrent access\n- **Extensible**: Easy to add new algorithms or storage backends\n- **Testable**: Mockable time provider and clear interfaces\n- **Production-ready**: Proper error handling, validation, and logging points\n- **Memory efficient**: Automatic cleanup of old timestamps\n\nThis implementation provides a solid foundation that can be extended for production use with additional features like distributed storage (Redis), metrics collection, or different rate limiting algorithms.",
    "output_tokens": 3756
  },
  {
    "problem_id": "rate_limiter",
    "problem_name": "Rate Limiter",
    "prompt": "Write a rate limiter that allows max N requests per minute for a given user ID.",
    "style": "simple",
    "response": "Here's a simple rate limiter using a dictionary to track requests per user:\n\n```python\nimport time\nfrom collections import defaultdict, deque\n\nclass RateLimiter:\n    def __init__(self, max_requests_per_minute):\n        self.max_requests = max_requests_per_minute\n        self.user_requests = defaultdict(deque)\n    \n    def is_allowed(self, user_id):\n        now = time.time()\n        user_queue = self.user_requests[user_id]\n        \n        # Remove requests older than 1 minute\n        while user_queue and user_queue[0] <= now - 60:\n            user_queue.popleft()\n        \n        # Check if under limit\n        if len(user_queue) < self.max_requests:\n            user_queue.append(now)\n            return True\n        \n        return False\n\n# Usage\nrate_limiter = RateLimiter(max_requests_per_minute=10)\n\n# Check if user can make a request\nif rate_limiter.is_allowed(\"user123\"):\n    print(\"Request allowed\")\nelse:\n    print(\"Rate limit exceeded\")\n```\n\nThat's it. Each user gets a deque that stores timestamps of their requests. When checking, we remove old timestamps and see if they're under the limit. Simple and works.",
    "output_tokens": 319
  },
  {
    "problem_id": "shopping_cart",
    "problem_name": "Shopping Cart",
    "prompt": "Write a shopping cart that can add items, remove items, apply discount codes, and calculate totals.",
    "style": "pattern_brained",
    "response": "I'll create a well-architected shopping cart system using design patterns and SOLID principles. Here's the implementation:\n\n```python\nfrom abc import ABC, abstractmethod\nfrom typing import Dict, List, Optional\nfrom decimal import Decimal\nfrom dataclasses import dataclass\nfrom enum import Enum\nimport uuid\n\n\n# Domain Models\n@dataclass(frozen=True)\nclass Product:\n    \"\"\"Immutable product representation.\"\"\"\n    id: str\n    name: str\n    price: Decimal\n    \n    def __post_init__(self):\n        if self.price < 0:\n            raise ValueError(\"Product price cannot be negative\")\n\n\n@dataclass\nclass CartItem:\n    \"\"\"Represents an item in the shopping cart.\"\"\"\n    product: Product\n    quantity: int\n    \n    def __post_init__(self):\n        if self.quantity <= 0:\n            raise ValueError(\"Quantity must be positive\")\n    \n    @property\n    def subtotal(self) -> Decimal:\n        return self.product.price * self.quantity\n\n\nclass DiscountType(Enum):\n    \"\"\"Types of discounts available.\"\"\"\n    PERCENTAGE = \"percentage\"\n    FIXED_AMOUNT = \"fixed_amount\"\n\n\n@dataclass(frozen=True)\nclass DiscountCode:\n    \"\"\"Immutable discount code representation.\"\"\"\n    code: str\n    discount_type: DiscountType\n    value: Decimal\n    minimum_amount: Optional[Decimal] = None\n    \n    def __post_init__(self):\n        if self.value < 0:\n            raise ValueError(\"Discount value cannot be negative\")\n        if self.discount_type == DiscountType.PERCENTAGE and self.value > 100:\n            raise ValueError(\"Percentage discount cannot exceed 100%\")\n\n\n# Strategy Pattern for Discount Calculation\nclass DiscountStrategy(ABC):\n    \"\"\"Abstract base class for discount calculation strategies.\"\"\"\n    \n    @abstractmethod\n    def calculate_discount(self, subtotal: Decimal, discount_code: DiscountCode) -> Decimal:\n        pass\n    \n    @abstractmethod\n    def is_applicable(self, subtotal: Decimal, discount_code: DiscountCode) -> bool:\n        pass\n\n\nclass PercentageDiscountStrategy(DiscountStrategy):\n    \"\"\"Strategy for percentage-based discounts.\"\"\"\n    \n    def calculate_discount(self, subtotal: Decimal, discount_code: DiscountCode) -> Decimal:\n        return subtotal * (discount_code.value / 100)\n    \n    def is_applicable(self, subtotal: Decimal, discount_code: DiscountCode) -> bool:\n        if discount_code.minimum_amount is None:\n            return True\n        return subtotal >= discount_code.minimum_amount\n\n\nclass FixedAmountDiscountStrategy(DiscountStrategy):\n    \"\"\"Strategy for fixed amount discounts.\"\"\"\n    \n    def calculate_discount(self, subtotal: Decimal, discount_code: DiscountCode) -> Decimal:\n        return min(discount_code.value, subtotal)  # Don't exceed subtotal\n    \n    def is_applicable(self, subtotal: Decimal, discount_code: DiscountCode) -> bool:\n        if discount_code.minimum_amount is None:\n            return True\n        return subtotal >= discount_code.minimum_amount\n\n\n# Factory Pattern for Discount Strategies\nclass DiscountStrategyFactory:\n    \"\"\"Factory for creating discount strategies.\"\"\"\n    \n    _strategies = {\n        DiscountType.PERCENTAGE: PercentageDiscountStrategy,\n        DiscountType.FIXED_AMOUNT: FixedAmountDiscountStrategy\n    }\n    \n    @classmethod\n    def create_strategy(cls, discount_type: DiscountType) -> DiscountStrategy:\n        strategy_class = cls._strategies.get(discount_type)\n        if not strategy_class:\n            raise ValueError(f\"Unknown discount type: {discount_type}\")\n        return strategy_class()\n\n\n# Repository Pattern for Discount Codes\nclass DiscountCodeRepository(ABC):\n    \"\"\"Abstract repository for discount codes.\"\"\"\n    \n    @abstractmethod\n    def find_by_code(self, code: str) -> Optional[DiscountCode]:\n        pass\n\n\nclass InMemoryDiscountCodeRepository(DiscountCodeRepository):\n    \"\"\"In-memory implementation of discount code repository.\"\"\"\n    \n    def __init__(self):\n        self._discount_codes: Dict[str, DiscountCode] = {}\n    \n    def add_discount_code(self, discount_code: DiscountCode) -> None:\n        self._discount_codes[discount_code.code] = discount_code\n    \n    def find_by_code(self, code: str) -> Optional[DiscountCode]:\n        return self._discount_codes.get(code)\n\n\n# Service Layer\nclass DiscountService:\n    \"\"\"Service for handling discount calculations.\"\"\"\n    \n    def __init__(self, discount_repository: DiscountCodeRepository):\n        self._discount_repository = discount_repository\n        self._strategy_factory = DiscountStrategyFactory()\n    \n    def apply_discount(self, subtotal: Decimal, discount_code: str) -> Decimal:\n        \"\"\"Apply discount and return the discount amount.\"\"\"\n        code = self._discount_repository.find_by_code(discount_code)\n        if not code:\n            raise ValueError(f\"Invalid discount code: {discount_code}\")\n        \n        strategy = self._strategy_factory.create_strategy(code.discount_type)\n        \n        if not strategy.is_applicable(subtotal, code):\n            raise ValueError(f\"Discount code {discount_code} is not applicable\")\n        \n        return strategy.calculate_discount(subtotal, code)\n\n\n# Observer Pattern for Cart Events\nclass CartObserver(ABC):\n    \"\"\"Observer interface for cart events.\"\"\"\n    \n    @abstractmethod\n    def on_item_added(self, cart_id: str, item: CartItem) -> None:\n        pass\n    \n    @abstractmethod\n    def on_item_removed(self, cart_id: str, product_id: str) -> None:\n        pass\n    \n    @abstractmethod\n    def on_item_updated(self, cart_id: str, item: CartItem) -> None:\n        pass\n\n\nclass CartEventLogger(CartObserver):\n    \"\"\"Example observer that logs cart events.\"\"\"\n    \n    def on_item_added(self, cart_id: str, item: CartItem) -> None:\n        print(f\"Added {item.quantity}x {item.product.name} to cart {cart_id}\")\n    \n    def on_item_removed(self, cart_id: str, product_id: str) -> None:\n        print(f\"Removed product {product_id} from cart {cart_id}\")\n    \n    def on_item_updated(self, cart_id: str, item: CartItem) -> None:\n        print(f\"Updated {item.product.name} quantity to {item.quantity} in cart {cart_id}\")\n\n\n# Main Shopping Cart Class\nclass ShoppingCart:\n    \"\"\"Main shopping cart class following SOLID principles.\"\"\"\n    \n    def __init__(self, discount_service: DiscountService):\n        self._id = str(uuid.uuid4())\n        self._items: Dict[str, CartItem] = {}\n        self._applied_discount_code: Optional[str] = None\n        self._discount_service = discount_service\n        self._observers: List[CartObserver] = []\n    \n    @property\n    def id(self) -> str:\n        return self._id\n    \n    def add_observer(self, observer: CartObserver) -> None:\n        \"\"\"Add an observer for cart events.\"\"\"\n        self._observers.append(observer)\n    \n    def remove_observer(self, observer: CartObserver) -> None:\n        \"\"\"Remove an observer.\"\"\"\n        if observer in self._observers:\n            self._observers.remove(observer)\n    \n    def _notify_item_added(self, item: CartItem) -> None:\n        for observer in self._observers:\n            observer.on_item_added(self._id, item)\n    \n    def _notify_item_removed(self, product_id: str) -> None:\n        for observer in self._observers:\n            observer.on_item_removed(self._id, product_id)\n    \n    def _notify_item_updated(self, item: CartItem) -> None:\n        for observer in self._observers:\n            observer.on_item_updated(self._id, item)\n    \n    def add_item(self, product: Product, quantity: int = 1) -> None:\n        \"\"\"Add an item to the cart.\"\"\"\n        if quantity <= 0:\n            raise ValueError(\"Quantity must be positive\")\n        \n        if product.id in self._items:\n            # Update existing item\n            existing_item = self._items[product.id]\n            new_quantity = existing_item.quantity + quantity\n            updated_item = CartItem(product, new_quantity)\n            self._items[product.id] = updated_item\n            self._notify_item_updated(updated_item)\n        else:\n            # Add new item\n            item = CartItem(product, quantity)\n            self._items[product.id] = item\n            self._notify_item_added(item)\n    \n    def remove_item(self, product_id: str) -> None:\n        \"\"\"Remove an item from the cart.\"\"\"\n        if product_id not in self._items:\n            raise ValueError(f\"Product {product_id} not found in cart\")\n        \n        del self._items[product_id]\n        self._notify_item_removed(product_id)\n    \n    def update_item_quantity(self, product_id: str, quantity: int) -> None:\n        \"\"\"Update the quantity of an item in the cart.\"\"\"\n        if product_id not in self._items:\n            raise ValueError(f\"Product {product_id} not found in cart\")\n        \n        if quantity <= 0:\n            self.remove_item(product_id)\n            return\n        \n        item = self._items[product_id]\n        updated_item = CartItem(item.product, quantity)\n        self._items[product_id] = updated_item\n        self._notify_item_updated(updated_item)\n    \n    def apply_discount_code(self, discount_code: str) -> None:\n        \"\"\"Apply a discount code to the cart.\"\"\"\n        # Validate the discount code by attempting to calculate discount\n        subtotal = self.get_subtotal()\n        self._discount_service.apply_discount(subtotal, discount_code)\n        self._applied_discount_code = discount_code\n    \n    def remove_discount_code(self) -> None:\n        \"\"\"Remove the applied discount code.\"\"\"\n        self._applied_discount_code = None\n    \n    def get_items(self) -> List[CartItem]:\n        \"\"\"Get all items in the cart.\"\"\"\n        return list(self._items.values())\n    \n    def get_subtotal(self) -> Decimal:\n        \"\"\"Calculate the subtotal (before discount).\"\"\"\n        return sum(item.subtotal for item in self._items.values())\n    \n    def get_discount_amount(self) -> Decimal:\n        \"\"\"Calculate the discount amount.\"\"\"\n        if not self._applied_discount_code:\n            return Decimal('0')\n        \n        subtotal = self.get_subtotal()\n        try:\n            return self._discount_service.apply_discount(subtotal, self._applied_discount_code)\n        except ValueError:\n            # Discount is no longer valid (e.g., minimum amount not met)\n            self._applied_discount_code = None\n            return Decimal('0')\n    \n    def get_total(self) -> Decimal:\n        \"\"\"Calculate the final total (after discount).\"\"\"\n        subtotal = self.get_subtotal()\n        discount = self.get_discount_amount()\n        return subtotal - discount\n    \n    def clear(self) -> None:\n        \"\"\"Clear all items from the cart.\"\"\"\n        for product_id in list(self._items.keys()):\n            self.remove_item(product_id)\n        self._applied_discount_code = None\n    \n    def is_empty(self) -> bool:\n        \"\"\"Check if the cart is empty.\"\"\"\n        return len(self._items) == 0\n\n\n# Example usage and demonstration\nif __name__ == \"__main__\":\n    # Set up dependencies\n    discount_repo = InMemoryDiscountCodeRepository()\n    discount_repo.add_discount_code(\n        DiscountCode(\"SAVE10\", DiscountType.PERCENTAGE, Decimal('10'))\n    )\n    discount_repo.add_discount_code(\n        DiscountCode(\"FLAT5\", DiscountType.FIXED_AMOUNT, Decimal('5.00'), Decimal('20.00'))\n    )\n    \n    discount_service = DiscountService(discount_repo)\n    cart = ShoppingCart(discount_service)\n    \n    # Add observer\n    logger = CartEventLogger()\n    cart.add_observer(logger)\n    \n    # Create products\n    laptop = Product(\"1\", \"Laptop\", Decimal('999.99'))\n    mouse = Product(\"2\", \"Mouse\", Decimal('29.99'))\n    keyboard = Product(\"3\", \"Keyboard\", Decimal('79.99'))\n    \n    # Add items to cart\n    cart.add_item(laptop, 1)\n    cart.add_item(mouse, 2)\n    cart.add_item(keyboard, 1)\n    \n    print(f\"Subtotal: ${cart.get_subtotal()}\")\n    \n    # Apply discount\n    cart.apply_discount_code(\"SAVE10\")\n    print(f\"Discount: ${cart.get_discount_amount()}\")\n    print(f\"Total: ${cart.get_total()}\")\n    \n    # Update quantity\n    cart.update_item_quantity(\"2\", 3)  # Update mouse quantity to 3\n    print(f\"Updated Total: ${cart.get_total()}\")\n    \n    # Remove item\n    cart.remove_item(\"3\")  # Remove keyboard\n    print(f\"Final Total: ${cart.get_total()}\")\n```\n\nThis shopping cart implementation demonstrates several key design patterns and architectural principles:\n\n## Design Patterns Used:\n\n1. **Strategy Pattern**: Different discount calculation strategies (percentage vs fixed amount)\n2. **Factory Pattern**: `DiscountStrategyFactory` creates appropriate discount strategies\n3. **Repository Pattern**: Abstracts discount code storage and retrieval\n4. **Observer Pattern**: Allows external components to react to cart events\n5. **Dependency Injection**: Cart depends on abstractions, not concrete implementations\n\n## SOLID Principles:\n\n1. **Single Responsibility**: Each class has one clear purpose\n2. **Open/Closed**: Easy to add new discount types or observers without modifying existing code\n3. **Liskov Substitution**: Implementations can be substituted for their interfaces\n4. **Interface Segregation**: Small, focused interfaces\n5. **Dependency Inversion**: Depends on abstractions, not concretions\n\n## Key Features:\n\n- **Thread-safe operations** through immutable domain objects\n- **Extensible discount system** - easy to add new discount types\n- **Event-driven architecture** through observers\n- **Proper error handling** with meaningful exceptions\n- **Clean separation of concerns** between domain, service, and infrastructure layers\n- **Type safety** with proper type hints throughout\n\nThe system is production-ready and can be easily extended with features like tax calculation, shipping, inventory management, or different storage backends.",
    "output_tokens": 3717
  },
  {
    "problem_id": "shopping_cart",
    "problem_name": "Shopping Cart",
    "prompt": "Write a shopping cart that can add items, remove items, apply discount codes, and calculate totals.",
    "style": "simple",
    "response": "```python\nclass ShoppingCart:\n    def __init__(self):\n        self.items = []\n        self.discount_codes = {\n            \"SAVE10\": 0.10,\n            \"SAVE20\": 0.20,\n            \"WELCOME\": 0.15\n        }\n        self.applied_discount = 0.0\n    \n    def add_item(self, name, price, quantity=1):\n        self.items.append({\"name\": name, \"price\": price, \"quantity\": quantity})\n    \n    def remove_item(self, name):\n        self.items = [item for item in self.items if item[\"name\"] != name]\n    \n    def apply_discount(self, code):\n        if code in self.discount_codes:\n            self.applied_discount = self.discount_codes[code]\n            return True\n        return False\n    \n    def get_subtotal(self):\n        return sum(item[\"price\"] * item[\"quantity\"] for item in self.items)\n    \n    def get_discount_amount(self):\n        return self.get_subtotal() * self.applied_discount\n    \n    def get_total(self):\n        return self.get_subtotal() - self.get_discount_amount()\n    \n    def show_cart(self):\n        if not self.items:\n            print(\"Cart is empty\")\n            return\n        \n        for item in self.items:\n            print(f\"{item['name']} x{item['quantity']} - ${item['price']:.2f} each\")\n        \n        print(f\"\\nSubtotal: ${self.get_subtotal():.2f}\")\n        if self.applied_discount > 0:\n            print(f\"Discount: -${self.get_discount_amount():.2f}\")\n        print(f\"Total: ${self.get_total():.2f}\")\n\n# Example usage:\ncart = ShoppingCart()\ncart.add_item(\"Apple\", 1.50, 3)\ncart.add_item(\"Banana\", 0.75, 2)\ncart.add_item(\"Orange\", 2.00, 1)\ncart.show_cart()\n\nprint(\"\\nApplying discount code SAVE10...\")\ncart.apply_discount(\"SAVE10\")\ncart.show_cart()\n\nprint(\"\\nRemoving Banana...\")\ncart.remove_item(\"Banana\")\ncart.show_cart()\n```\n\nThis shopping cart does exactly what you asked for in the simplest way possible:\n\n- **Add items**: `add_item(name, price, quantity)`\n- **Remove items**: `remove_item(name)` \n- **Apply discounts**: `apply_discount(code)` with predefined codes\n- **Calculate totals**: `get_total()`, `get_subtotal()`, `get_discount_amount()`\n\nNo unnecessary abstractions, no multiple files, no complex inheritance. Just a single class that stores items in a list and calculates totals with basic math.",
    "output_tokens": 711
  }
]